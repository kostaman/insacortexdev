C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE TPL_OS_TASK
OBJECT MODULE PLACED IN .\objs\tpl_os_task.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\..\trampoline-1.1\os\tpl_os_task.c TINY BROWSE INCDIR(.\ar
                    -chi_appli;..\..\..\trampoline-1.1\os;..\..\..\trampoline-1.1\com;..\..\..\trampoline-1.1\os\os_machine\c166;..\..\..\tra
                    -mpoline-1.1\goil\templates\c166;..\..\..\trampoline-1.1\debug) MOD167 DEFINE(WITH_COMPILER_SETTINGS) DEBUG PRINT(.\tpl_o
                    -s_task.lst) OBJECT(.\objs\tpl_os_task.obj) 

 stmt lvl     source

    1         /**
    2          * @file tpl_os_task_management.c
    3          *
    4          * @section desc File description
    5          *
    6          * Trampoline Task Management Calls
    7          *
    8          * @section copyright Copyright
    9          *
   10          * Trampoline OS
   11          *
   12          * Trampoline is copyright (c) IRCCyN 2005+
   13          * Copyright ESEO for function and data structures documentation
   14          * Copyright IRISA - JF Deverge for libpcl port
   15          * Copyright AYRTON TECHNOLOGY for hcs12 port
   16          * Trampoline is protected by the French intellectual property law.
   17          *
   18          * This software is distributed under the Lesser GNU Public Licence
   19          *
   20          * @section infos File informations
   21          *
   22          * $Date: 2007-11-30 14:24:05 +0100 (Fri, 30 Nov 2007) $
   23          * $Rev: 405 $
   24          * $Author: jlb $
   25          * $URL: https://trampoline.rts-software.org/svn/trunk/os/tpl_os_task.c $
   26          */
   27         
   28         #include "tpl_os.h"
   29         #include "tpl_os_kernel.h"
   30         #include "tpl_machine_interface.h"
   31         #include "tpl_os_error.h"
   32         #include "tpl_os_hooks.h"
   33         
   34         #define OS_START_SEC_CODE
   35         #include "tpl_memmap.h"
   36         
   37         /*
   38          * OSEK/VDX API services
   39          *
   40          * see header file documentation or refer to the OSEK/VDX 2.2.2 specification
   41          */
   42         FUNC(StatusType, OS_CODE) ActivateTask(
   43             CONST(TaskType, AUTOMATIC) task_id)
   44         {
   45  1          /*  init the error to no error  */
   46  1          VAR(StatusType, AUTOMATIC) result = E_OK;
   47  1      
   48  1          /*  lock the task structures    */
   49  1          LOCK_WHEN_TASK()
   50  1      
   51  1          /*  store information for error hook routine    */
   52  1          STORE_SERVICE(OSServiceId_ActivateTask)
C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 2   

   53  1          STORE_TASK_ID(task_id)
   54  1      
   55  1          /*  Check a task_id error   */
   56  1          CHECK_TASK_ID_ERROR(task_id,result)
   57  1      
   58  1      #ifndef NO_TASK
   59  1          IF_NO_EXTENDED_ERROR(result)
   60  1              result = tpl_activate_task(tpl_task_table[task_id]);
   61  1              if (result == (tpl_status)E_OK_AND_SCHEDULE)
   62  1              {
   63  2                  tpl_schedule(FROM_TASK_LEVEL);
   64  2              }
   65  1              result &= OSEK_STATUS_MASK;
   66  1          IF_NO_EXTENDED_ERROR_END()
   67  1      #endif
   68  1      
   69  1          PROCESS_ERROR(result)
   70  1      
   71  1          /*  unlock the task structures  */
   72  1          UNLOCK_WHEN_TASK()
   73  1      
   74  1          return result;
   75  1      }
   76         
   77         
   78         FUNC(StatusType, OS_CODE) TerminateTask(void)
   79         {
   80  1          /*  init the error to no error  */
   81  1          VAR(StatusType, AUTOMATIC) result = E_OK;
   82  1      
   83  1          /*  lock the task structures    */
   84  1          LOCK_WHEN_TASK()
   85  1      
   86  1          /*  store information for error hook routine    */
   87  1          STORE_SERVICE(OSServiceId_TerminateTask)
   88  1      
   89  1          /*  check we are at the task level  */
   90  1          CHECK_TASK_CALL_LEVEL_ERROR(result)
   91  1          /*  check the task does not own a resource  */
   92  1          CHECK_RUNNING_OWNS_REZ_ERROR(result)
   93  1      
   94  1      #ifndef NO_TASK
   95  1          IF_NO_EXTENDED_ERROR(result)
   96  1      
   97  1              /*  set the state of the running task to DYING                  */
   98  1              tpl_running_obj->state = (tpl_exec_state)DYING;
   99  1      
  100  1              /*  and let the scheduler do its job                            */
  101  1              tpl_schedule(FROM_TASK_LEVEL);
  102  1      
  103  1          IF_NO_EXTENDED_ERROR_END()
  104  1      #endif
  105  1      
  106  1          PROCESS_ERROR(result)
  107  1      
  108  1          /*  unlock the task structures  */
  109  1          UNLOCK_WHEN_TASK()
  110  1      
  111  1          return result;
  112  1      }
  113         
  114         
C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 3   

  115         FUNC(StatusType, OS_CODE) ChainTask(
  116             CONST(TaskType, AUTOMATIC) task_id)
  117         {
  118  1          VAR(StatusType, AUTOMATIC) result = E_OK;
  119  1      
  120  1      #ifndef NO_TASK
  121  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) exec_obj;
  122  1      #endif
  123  1      
  124  1          /*  lock the task system    */
  125  1          LOCK_WHEN_TASK()
  126  1      
  127  1          /*  store information for error hook routine    */
  128  1          STORE_SERVICE(OSServiceId_ChainTask)
  129  1          STORE_TASK_ID(task_id)
  130  1      
  131  1          /*  Check a call level error    */
  132  1          CHECK_TASK_CALL_LEVEL_ERROR(result)
  133  1          /*  Check a task_id error       */
  134  1          CHECK_TASK_ID_ERROR(task_id,result)
  135  1          /*  Check no resource is held by the terminating task   */
  136  1          CHECK_RUNNING_OWNS_REZ_ERROR(result)
  137  1      
  138  1      #ifndef NO_TASK
  139  1          IF_NO_EXTENDED_ERROR(result)
  140  1      
  141  1              exec_obj = &((tpl_task_table[task_id])->exec_desc);
  142  1      
  143  1              if (exec_obj == tpl_running_obj)
  144  1              {
  145  2                  /*  The activated task and the currentily running object
  146  2                      are the same. So the task is put in the RESURRECT state.    */
  147  2                  tpl_running_obj->state = RESURRECT;
  148  2      
  149  2              }
  150  1              else
  151  1              {
  152  2                  tpl_activate_counter    count = exec_obj->activate_count;
  153  2      
  154  2                  if (count < exec_obj->static_desc->max_activate_count)
  155  2                  {
  156  3                      if (count == 0)
  157  3                      {
  158  4                          if (exec_obj->static_desc->type == TASK_EXTENDED)
  159  4                          {
  160  5                              /*  if the task is an extended one,
  161  5                                  it is initialized now                           */
  162  5                              exec_obj->state = (tpl_exec_state)READY;
  163  5                              tpl_init_exec_object(exec_obj);
  164  5                          }
  165  4                          else
  166  4                          {
  167  5                              /*  if it is a basic task, its initialization is
  168  5                                  postponed to the time it will get the CPU       */
  169  5                              exec_obj->state = (tpl_exec_state)READY_AND_NEW;
  170  5                          }
  171  4                      }
  172  3                      /*  put it in the list  */
  173  3                      tpl_put_new_exec_object(exec_obj);
  174  3      
  175  3                      /*  inc the task activation count. When the task
  176  3                          will terminate it will dec this count and if
C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 4   

  177  3                          not zero it will be reactivated                         */
  178  3                      exec_obj->activate_count++;
  179  3      
  180  3                      /*  the object that is currently running is put in
  181  3                          the DYING state                                         */
  182  3                      tpl_running_obj->state = DYING;
  183  3                  }
  184  2                  else
  185  2                  {
  186  3                      /*  The max activation count is reached. So an error occurs */
  187  3                      result = E_OS_LIMIT;
  188  3                  }
  189  2              }
  190  1      
  191  1              if (result == E_OK)
  192  1              {
  193  2                  /*  and let the scheduler do its job                            */
  194  2                  tpl_schedule(FROM_TASK_LEVEL);
  195  2              }
  196  1      
  197  1          IF_NO_EXTENDED_ERROR_END()
  198  1      #endif
  199  1      
  200  1          PROCESS_ERROR(result)
  201  1      
  202  1          /*  unlock the task structures  */
  203  1          UNLOCK_WHEN_TASK()
  204  1      
  205  1          return result;
  206  1      }
  207         
  208         
  209         FUNC(StatusType, OS_CODE) Schedule(void)
  210         {
  211  1          VAR(StatusType, AUTOMATIC) result = E_OK;
  212  1      
  213  1          /*  lock the task system    */
  214  1          LOCK_WHEN_TASK()
  215  1      
  216  1          /*  store information for error hook routine    */
  217  1          STORE_SERVICE(OSServiceId_Schedule)
  218  1      
  219  1          /*  Check a call level error    */
  220  1          CHECK_TASK_CALL_LEVEL_ERROR(result)
  221  1          /*  Check no resource is held by the calling task   */
  222  1          CHECK_RUNNING_OWNS_REZ_ERROR(result)
  223  1      
  224  1      #ifndef NO_TASK
  225  1          IF_NO_EXTENDED_ERROR(result)
  226  1              /*  release the internal resource   */
  227  1              tpl_release_internal_resource(tpl_running_obj);
  228  1              /*  does the rescheduling           */
  229  1              tpl_schedule(FROM_TASK_LEVEL);
  230  1              /*  get the internal resource       */
  231  1              tpl_get_internal_resource(tpl_running_obj);
  232  1          IF_NO_EXTENDED_ERROR_END()
  233  1      #endif
  234  1      
  235  1          PROCESS_ERROR(result)
  236  1      
  237  1          /*  unlock the task structures  */
  238  1          UNLOCK_WHEN_TASK()
C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 5   

  239  1      
  240  1          return result;
  241  1      }
  242         
  243         
  244         FUNC(StatusType, OS_CODE) GetTaskID(
  245             VAR(TaskRefType, AUTOMATIC) task_id)
  246         {
  247  1          /*  get the task id from the task descriptor.
  248  1              note : the idle task has an id set to INVALID_TASK
  249  1              Done when the idle task is running, tpl_get_task_id
  250  1              returns naturally INVALID_TASK in task_id   */
  251  1          *task_id = tpl_running_obj->static_desc->id;
  252  1      
  253  1          return E_OK;
  254  1      }
  255         
  256         
  257         FUNC(StatusType, OS_CODE) GetTaskState(
  258             CONST(TaskType, AUTOMATIC)        task_id,
  259             VAR(TaskStateRefType, AUTOMATIC)  state)
  260         {
  261  1          VAR(StatusType, AUTOMATIC) result = E_OK;
  262  1      
  263  1          LOCK_WHEN_HOOK()
  264  1      
  265  1          /*  store information for error hook routine    */
  266  1          STORE_SERVICE(OSServiceId_GetTaskState)
  267  1          STORE_TASK_STATE_REF(state)
  268  1      
  269  1          /*  Check a task_id error       */
  270  1          CHECK_TASK_ID_ERROR(task_id,result)
  271  1      
  272  1      #ifndef NO_TASK
  273  1          IF_NO_EXTENDED_ERROR(result)
  274  1              /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
  275  1                  that has the same beginning fields as the struct it is casted to
  276  1                  This allow object oriented design and polymorphism.
  277  1              */
  278  1              *state = ((P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC))(tpl_task_table[task_id]))->state & 0x3
             -;
  279  1          IF_NO_EXTENDED_ERROR_END()
  280  1      #endif
  281  1      
  282  1          PROCESS_ERROR(result)
  283  1      
  284  1          UNLOCK_WHEN_HOOK()
  285  1      
  286  1          return result;
  287  1      }
  288         
  289         #define OS_STOP_SEC_CODE
  290         #include "tpl_memmap.h"
  291         
  292         /* End of file tpl_os_task.c */


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         298     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
C166 COMPILER V6.08, TPL_OS_TASK                                                           06/28/2009 16:38:36 PAGE 6   

  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =    --------     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
