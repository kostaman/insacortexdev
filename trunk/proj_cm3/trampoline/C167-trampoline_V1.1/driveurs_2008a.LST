C166 COMPILER V6.18, DRIVEURS_2008A                                                        07/06/2009 12:40:22 PAGE 1   


C166 COMPILER V6.18, COMPILATION OF MODULE DRIVEURS_2008A
OBJECT MODULE PLACED IN .\objs\driveurs_2008a.obj
COMPILER INVOKED BY: E:\programs\keil_arm_eval\C166\BIN\C166.EXE driveurs_2008a.c TINY BROWSE INCDIR(.\archi_appli;..\..
                    -\..\trampoline-1.1_svn\os;..\..\..\trampoline-1.1_svn\com;..\..\..\trampoline-1.1_svn\machines\c166;..\..\..\trampoline-
                    -1.1_svn\debug;..\..\..\trampoline-1.1_svn\goil\templates\c166) MOD167 DEFINE(WITH_COMPILER_SETTINGS) DEBUG OBJECT(.\objs
                    -\driveurs_2008a.obj) 

 stmt lvl     source

    1         // Librairie de gestion des PERIPHs
    2         #include <c167cs.h>
    3         #include "driveurs_2008a.h"
    4         
    5         
    6         //=================================================================================================
    7         //
    8         //       Commentaires  :   Version 3_1
    9         //      
   10         //
   11         //______________________________________________________________________
   12         // Test effectués:
   13         // init à 10m. Avancée de 9m environ, recul idem => aucun pas raté, l'overflow se passe bien à priori
   14         // init à 10m, avancée de 100m environ, recul idem, aucun problème
   15         // init à 0m, avancée de 170mn recule de 170m, aucun pb.
   16         // 
   17         // NB: la précision est due au pas estimée de la roue ( 0.004254236)  , lié au diamètre...
   18         
   19         
   20         //___________________ADC___________________________________
   21         //
   22         // Voici la correspondance : [-12km/h  0km/h  +12km/h] = [-3.333.. m/s  0  +3.333..m/s] =>[0  2V5  5V]
   23         // Test (simu seule)
   24         // Conforme pour les 3 valeurs de l'intervalle 
   25         // La fonction Lire_Vitesse() dure 33us environ, dont 11us pour l'acquisition en scrutation
   26         // et 22 us pour le calcul flottant.
   27         
   28         
   29         //___________________PWM___________________________________
   30         //
   31         // Sur la voie 7.1 (simu)
   32         // testé en simu. conforme pour des valeurs de -1.0 à +1.0 OK
   33         // testé pour -50.0 et +50.0 (n'importe quoi !) ok, saturation correcte de la PWM
   34         // durée de la fonction Fixe_vitesse(..) : 50us environ (du au calcul flottant vers int)
   35         
   36         //__________________LEDS____________________________________
   37         //Bibliotheque de gestion d'une LED pour la prise en main de tiny
   38         
   39         
   40         
   41         //=================================================================================================
   42         // unite Capcom, variables permanente globale à ce fichier______________________
   43         // elles sont figées en RAM
   44         int N_Pulse;
   45         
   46         
   47         
   48         
   49         //=================================================================================================
   50         //
   51         //       Les sous-programmes
   52         //      
C166 COMPILER V6.18, DRIVEURS_2008A                                                        07/06/2009 12:40:22 PAGE 2   

   53         //=================================================================================================
   54         
   55         
   56         void Configurer_Tout_Les_Periphs(void)
   57         {
   58  1              
   59  1      
   60  1      
   61  1      
   62  1              //1 Configuration des periphs
   63  1              Config_PWM();
   64  1              Config_ADConverter();
   65  1              Config_Capture();
   66  1              Init_Led();
   67  1              Init_Position(90.0);
   68  1              Fixe_Rapport(0.0);
   69  1      
   70  1              IEN     =1;
   71  1      
   72  1      }
   73         
   74         
   75         //______________________________________________________________________________________________
   76         //
   77         //  Config_ADConverter 
   78         //  règle le timing de l'échantllonneur du c167 et protège les voies 6 et 7 du bruit numérique 
   79         //  Ressources utilisées :
   80         //       
   81         //   
   82         //______________________________________________________________________________________________
   83         
   84         //______________________________________________________________________________________________
   85         //
   86         //  Config_ADConverter 
   87         //  place P5.5 en entrée
   88         // configure l'ADC Tconv #9.7us channel 5
   89         //       
   90         //   
   91         //______________________________________________________________________________________________
   92         
   93         void Config_ADConverter(void)
   94         {
   95  1      // P5.5 =>      
   96  1      
   97  1      // deconnexion des circuits numériques du port P5 (bruit, P5.5)
   98  1      P5DIDIS=P5DIDIS | 0x0020;
   99  1      
  100  1      // config de l'ADC:
  101  1      // Mode simple,CAIN=33pF, Rsource # 1000 => charge OK à 5*RC = 165ns = ts.
  102  1      // Configuré comme suit, à 20MHz => Tconv = tBC*8 + 40tBC + 2 tCPU 
  103  1      //                                                                                = 48*tCPU*4 + 2tCPU = 194/20Meg = 9,7 us
  104  1      //                                                                              dont  ts = 8*tBC = 8*4/20M = 1,6us >> 165ns: OK
  105  1      //
  106  1      
  107  1       
  108  1      // ADCON = 0000 xxxx  xx00 0101
  109  1      ADCON=ADCON|0x0005;
  110  1      ADCON=ADCON&0x0FC5;
  111  1      }
  112         
  113         
  114          //______________________________________________________________________________________________
C166 COMPILER V6.18, DRIVEURS_2008A                                                        07/06/2009 12:40:22 PAGE 3   

  115         //
  116         // float Lire_Vitesse();
  117         // lit la valeur lue par l'ADC, en float : 
  118         // [-12km/h  0km/h  +12km/h] = [-3.333.. m/s  0  +3.333..m/s] =>[0V  2V5  0V]
  119         //       
  120         //   
  121         //______________________________________________________________________________________________
  122         
  123         float Lire_Vitesse_Float(void)
  124         {
  125  1      float Vitesse_Lue;
  126  1      int Nbre;
  127  1      
  128  1      // Start
  129  1      ADST=1;
  130  1      while(ADBSY)
  131  1              {};
  132  1      Nbre=ADDAT & 0x03FF;
  133  1      // [0V  5V] =>[0  1023]
  134  1      Nbre=Nbre-512;
  135  1      // [0V  5V] =>[-512  +511]
  136  1      
  137  1      Vitesse_Lue=((float)Nbre)*0.00651042;
  138  1      // [0V  5V] =>[-3.33sm/s  +3.326m/s] (=[-12km/h + 12km/h])
  139  1      
  140  1      return(Vitesse_Lue);
  141  1      }
  142         
  143         //______________________________________________________________________________________________
  144         //
  145         // int Lire_Vitesse();
  146         // lit la valeur lue par l'ADC, en float : 
  147         // [-12km/h  0km/h  +12km/h] = [-3.333.. m/s  0  +3.333..m/s] =>[0V  2V5  0V] => [-511 0 512]
  148         //       
  149         //   
  150         //______________________________________________________________________________________________
  151         
  152         signed int Lire_Vitesse(void)
  153         {
  154  1      
  155  1      // Start
  156  1      ADST=1;
  157  1      while(ADBSY)
  158  1              {};
  159  1      
  160  1      return ((signed int)( ADDAT & 0x03FF) - 511);
  161  1      }
  162         
  163         
  164         
  165         
  166         //______________________________________________________________________________________________
  167         //
  168         //  
  169         //   
  170         //______________________________________________________________________________________________
  171         
  172         void Config_Capture(void)
  173         {
  174  1      
  175  1      
  176  1      T3CON=0x0173; // T3 en mode codeur incremental
C166 COMPILER V6.18, DRIVEURS_2008A                                                        07/06/2009 12:40:22 PAGE 4   

  177  1      DP3 = DP3 & ~(1<<4);   // P3.4 orientée IN
  178  1      DP3 = DP3 & ~(1<<6);   // P3.6 orientée IN
  179  1      T3UD=SENS;      // sens de comptage selon les voies A et B
  180  1      }
  181         
  182         signed int Position ;
  183         signed int Lire_Position(void)
  184         {
  185  1              Position =  (signed int) T3;
  186  1              return Position;
  187  1      }
  188         
  189         
  190         void Init_Position(signed int Position_Initiale)
  191         {
  192  1              Position = Position_Initiale;
  193  1              T3=      (unsigned int) Position;
  194  1      }
  195         
  196         
  197         
  198         
  199         //______________________________________________________________________________________________
  200         
  201         void Config_PWM(void)    // P7.1 
  202         {
  203  1      // PWM1 validée, Clk à 20MHz => si on prend un PT1=1024, on est à 20kHz de découpage
  204  1      // 
  205  1      // PWMCON0 = xxxx xx0x xx0x xx0x 
  206  1      // PWMCON1 = xxx0 xxxx xx0x xx1x
  207  1      PWMCON0=PWMCON0&0xFDDD;
  208  1      PWMCON1=PWMCON1&0xEFDF;
  209  1      PWMCON1=PWMCON1|0x0002;
  210  1      
  211  1      PT1=0;  // le timer à 0
  212  1      PW1=0;  // au depart, duty = 0
  213  1      PP1=1024; // période qui donnera environ 20k
  214  1      
  215  1      
  216  1      /* Configuration PORT7.1 en sortie pushpull     */       
  217  1      // ODP7.1 = 0, 
  218  1      ODP7=ODP7&0XFFFD;
  219  1      // DP7.1 =1, bit 1 du port7 en sortie
  220  1      DP7=DP7|0X0002;
  221  1      
  222  1      // P7.1 = 1, pour replacer la PWM en phase (inversion par XOR nécessaire)
  223  1      P7=P7|0X0002;
  224  1      
  225  1      // demarrage timer PWM1 
  226  1      PTR1=1;
  227  1      
  228  1      
  229  1      }
  230         
  231         void Fixe_Rapport(float Sigma)
  232         {
  233  1              float valeur;
  234  1              signed int valeur_entiere;
  235  1      
  236  1              valeur = (512.0*Sigma);
  237  1              // -512.0 à +511.0
  238  1              valeur_entiere = (signed int) valeur;
C166 COMPILER V6.18, DRIVEURS_2008A                                                        07/06/2009 12:40:22 PAGE 5   

  239  1              valeur_entiere = valeur_entiere+512;
  240  1              if (valeur_entiere>1023) valeur_entiere=1023;
  241  1              if (valeur_entiere<1) valeur_entiere=1;
  242  1              PW1=valeur_entiere;
  243  1      }
  244         
  245         //_________________________________________LEDS__________________
  246         // initLED avant la première utilisation (inite les LEDS éteintes)
  247         // puis  appel de modifierLed1 ou 2 pour changer son état
  248         
  249          void Init_Led(void){
  250  1              DP2=0x00FF;
  251  1              ODP2=0x00;
  252  1              P2 =   P2 & 0xFF00;
  253  1      }
  254         void Modifier_Led_1(void){
  255  1              P2=P2 ^ 0x01;
  256  1      }
  257         
  258         void Modifier_Led_2(void){
  259  1              P2=P2 ^ 0x02;
  260  1      }        
  261         
  262         void Toggle_Led(unsigned char Num_Led){
  263  1              P2=P2 ^ (1<<Num_Led);
  264  1      }
  265         
  266         void Set_Led(unsigned char Num_Led){
  267  1              P2=P2 | (1<<Num_Led);
  268  1      }
  269         
  270         void Reset_Led(unsigned char Num_Led){
  271  1              P2=P2 & ~(1<<Num_Led);
  272  1      }
  273         //______________________________________________________________________________________________
  274         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         296     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =           4     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
