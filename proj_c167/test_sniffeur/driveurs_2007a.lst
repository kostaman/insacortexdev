C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE DRIVEURS_2007A
OBJECT MODULE PLACED IN .\driveurs_2007a.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\includes\libs\driveurs_2007a.c BROWSE INCDIR(..\..\libs_th
                    -ierry\SourceC167\Developpement_Capcom_V2) MOD167 DEBUG PRINT(.\driveurs_2007a.lst) OBJECT(.\driveurs_2007a.obj) 

 stmt lvl     source

    1         // Librairie de gestion des PERIPHs
    2         #include <c167cs.h>
    3         #include "../../includes/libs/driveurs_2007a.h"
    4         // entrées des codeurs incrémentaux
    5         sbit Opto_8=P2^8;
    6         sbit Opto_9=P2^9;
    7         
    8         
    9         
   10         //=================================================================================================
   11         //
   12         //       Commentaires  :   Version 3_1
   13         //      
   14         //
   15         //______________________________________________________________________
   16         // Test effectués:
   17         // init à 10m. Avancée de 9m environ, recul idem => aucun pas raté, l'overflow se passe bien à priori
   18         // init à 10m, avancée de 100m environ, recul idem, aucun problème
   19         // init à 0m, avancée de 170mn recule de 170m, aucun pb.
   20         // 
   21         // NB: la précision est due au pas estimée de la roue ( 0.004254236)  , lié au diamètre...
   22         
   23         
   24         //___________________ADC___________________________________
   25         //
   26         // Voici la correspondance : [-12km/h  0km/h  +12km/h] = [-3.333.. m/s  0  +3.333..m/s] =>[0  2V5  5V]
   27         // Test (simu seule)
   28         // Conforme pour les 3 valeurs de l'intervalle 
   29         // La fonction Lire_Vitesse() dure 33us environ, dont 11us pour l'acquisition en scrutation
   30         // et 22 us pour le calcul flottant.
   31         
   32         
   33         //___________________PWM___________________________________
   34         //
   35         // Sur la voie 7.1 (simu)
   36         // testé en simu. conforme pour des valeurs de -1.0 à +1.0 OK
   37         // testé pour -50.0 et +50.0 (n'importe quoi !) ok, saturation correcte de la PWM
   38         // durée de la fonction Fixe_vitesse(..) : 50us environ (du au calcul flottant vers int)
   39         
   40         //__________________LEDS____________________________________
   41         //Bibliotheque de gestion d'une LED pour la prise en main de tiny
   42         
   43         
   44         
   45         //=================================================================================================
   46         // unite Capcom, variables permanente globale à ce fichier______________________
   47         // elles sont figées en RAM
   48         int N_Pulse;
   49         
   50         
   51         
   52         
   53         //=================================================================================================
   54         //
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 2   

   55         //       Les sous-programmes
   56         //      
   57         //=================================================================================================
   58         
   59         
   60         void Configurer_Tout_Les_Periphs(void)
   61         {
   62  1              
   63  1      
   64  1      
   65  1      
   66  1              //1 Configuration des periphs
   67  1              Config_PWM();
   68  1              Config_ADConverter();
   69  1              Config_Capture();
   70  1              Init_Led();
   71  1              Init_Position(90.0);
   72  1              Fixe_Rapport(0.0);
   73  1      
   74  1              IEN     =1;
   75  1      
   76  1      }
   77         
   78         
   79         //______________________________________________________________________________________________
   80         //
   81         //  Config_ADConverter 
   82         //  règle le timing de l'échantllonneur du c167 et protège les voies 6 et 7 du bruit numérique 
   83         //  Ressources utilisées :
   84         //       
   85         //   
   86         //______________________________________________________________________________________________
   87         
   88         //______________________________________________________________________________________________
   89         //
   90         //  Config_ADConverter 
   91         //  place P5.5 en entrée
   92         // configure l'ADC Tconv #9.7us channel 5
   93         //       
   94         //   
   95         //______________________________________________________________________________________________
   96         
   97         void Config_ADConverter(void)
   98         {
   99  1      // P5.5 =>      
  100  1      
  101  1      // deconnexion des circuits numériques du port P5 (bruit, P5.5)
  102  1      P5DIDIS=P5DIDIS | 0x0020;
  103  1      
  104  1      // config de l'ADC:
  105  1      // Mode simple,CAIN=33pF, Rsource # 1000 => charge OK à 5*RC = 165ns = ts.
  106  1      // Configuré comme suit, à 20MHz => Tconv = tBC*8 + 40tBC + 2 tCPU 
  107  1      //                                                                                = 48*tCPU*4 + 2tCPU = 194/20Meg = 9,7 us
  108  1      //                                                                              dont  ts = 8*tBC = 8*4/20M = 1,6us >> 165ns: OK
  109  1      //
  110  1      
  111  1       
  112  1      // ADCON = 0000 xxxx  xx00 0101
  113  1      ADCON=ADCON|0x0005;
  114  1      ADCON=ADCON&0x0FC5;
  115  1      }
  116         
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 3   

  117         
  118            
  119         
  120         
  121         
  122         //______________________________________________________________________________________________
  123         //
  124         // float Lire_Vitesse();
  125         // lit la valeur lue par l'ADC, en float : 
  126         // [-12km/h  0km/h  +12km/h] = [-3.333.. m/s  0  +3.333..m/s] =>[0V  2V5  0V]
  127         //       
  128         //   
  129         //______________________________________________________________________________________________
  130         
  131         float Lire_Vitesse()
  132         {
  133  1      float Vitesse_Lue;
  134  1      int Nbre;
  135  1      
  136  1      // Start
  137  1      ADST=1;
  138  1      while(ADBSY)
  139  1              {};
  140  1      Nbre=ADDAT & 0x03FF;
  141  1      // [0V  5V] =>[0  1023]
  142  1      Nbre=Nbre-512;
  143  1      // [0V  5V] =>[-512  +511]
  144  1      
  145  1      Vitesse_Lue=((float)Nbre)*0.00651042;
  146  1      // [0V  5V] =>[-3.33sm/s  +3.326m/s] (=[-12km/h + 12km/h])
  147  1      
  148  1      return(Vitesse_Lue);
  149  1      }
  150         
  151         
  152         
  153         //______________________________________________________________________________________________
  154         //
  155         //  
  156         //   
  157         //______________________________________________________________________________________________
  158         
  159         void Config_Capture(void)
  160         {
  161  1      
  162  1      // initialisation  CAPCOM2
  163  1      // utilisation des broches P2.8 et P2.9 en IT (cc8io et cc9io)
  164  1      // fronts montant et descendants:  reg CCM2
  165  1      // CCMOD8 = 011 (positive & negative edge)
  166  1      // CCMOD9 = 011 (positive & negative edge)
  167  1      // Acc8 = 0 => alloué à T7 arbitraire ! on se sert pas de la capture
  168  1      // Acc9 = 0 => alloué à T7 arbitraire ! on se sert pas de la capture
  169  1      //  => CCM2 = |xxxx,xxxx,0011,0011
  170  1      
  171  1      CCM2=CCM2|0x0033;
  172  1      CCM2=CCM2&0xFF33;  
  173  1      
  174  1      // P2.8 et P2.9 en entrée
  175  1      DP2=DP2&0XFCFF;
  176  1      
  177  1      // init des positions
  178  1      N_Pulse=0;
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 4   

  179  1      
  180  1      //config des interruptions
  181  1      
  182  1      
  183  1      CC8IC = (OPTO_IT_ILVL << 2) + OPTO_IT_GLVL;
  184  1      CC9IC = (OPTO_IT_ILVL << 2) + OPTO_IT_GLVL+1;
  185  1      CC8IE=1;
  186  1      CC9IE=1;
  187  1      
  188  1      }
  189         
  190         
  191         
  192         //Temps d'exécution d'une interruption  457 cycles soit 23µs
  193         //Période maxi = 1/750hz=1,3ms TpsExec/P=0.0177
  194         void IT_CC8(void) interrupt 0x18
  195         //                              ____      ____
  196         //  Opto_8 : __|    |____|    |__   : marche avant
  197         //                                ____      ____
  198         //  Opto_9 :   __|    |____|    |__
  199         
  200         // ou
  201         //                              ____      ____
  202         //  Opto_8 : __|    |____|    |__   : marche arrière
  203         //                    ____          ____
  204         //  Opto_9 __|    |____|    |__
  205         // 
  206         {
  207  1              
  208  1      if      (Opto_8==1)     // c'est un front montant de Opto_8
  209  1              {
  210  2              if (Opto_9==0) // marche avant
  211  2                      {
  212  3                      N_Pulse=N_Pulse+1;
  213  3                      // modulo 30 000
  214  3                      if (N_Pulse>=30000)
  215  3                              {
  216  4                               N_Pulse=0;
  217  4                              }
  218  3                      }
  219  2              else       // marche arrière
  220  2                      {
  221  3                      N_Pulse=N_Pulse-1;
  222  3                      if (N_Pulse<=-30000)
  223  3                              {
  224  4                               N_Pulse=0;
  225  4                              
  226  4                              }
  227  3                      }
  228  2              }
  229  1      else // c'est un front descendant
  230  1              {
  231  2              if (Opto_9==1) // marche avant
  232  2                      {
  233  3                      N_Pulse=N_Pulse+1;
  234  3                      // modulo 30 000
  235  3                      if (N_Pulse>=30000)
  236  3                              {
  237  4                               N_Pulse=0;
  238  4                               
  239  4                              }
  240  3                      }
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 5   

  241  2              else       // marche arrière
  242  2                      {
  243  3                      N_Pulse=N_Pulse-1;
  244  3                      if (N_Pulse<=-30000)
  245  3                              {
  246  4                               N_Pulse=0;
  247  4                              }
  248  3                      }
  249  2              }
  250  1      }
  251         
  252         
  253         void IT_CC9(void) interrupt 0x19
  254         
  255         //                              ____      ____
  256         //  Opto_8 : __|    |____|    |__   : marche avant
  257         //                                ____      ____
  258         //  Opto_9 :   __|    |____|    |__
  259         
  260         // ou
  261         //                              ____      ____
  262         //  Opto_8 : __|    |____|    |__   : marche arrière
  263         //                    ____          ____
  264         //  Opto_9 __|    |____|    |__
  265         // 
  266         {
  267  1              
  268  1      if      (Opto_9==1)     // c'est un front montant de Opto_9
  269  1              {
  270  2              if (Opto_8==1) // marche avant
  271  2                      {
  272  3                      N_Pulse=N_Pulse+1;
  273  3                      // modulo 30 000
  274  3                      if (N_Pulse>=30000)
  275  3                              {
  276  4                               N_Pulse=0;
  277  4                              
  278  4                              }
  279  3                      }
  280  2              else       // marche arrière
  281  2                      {
  282  3                      N_Pulse=N_Pulse-1;
  283  3                      // modulo 30 000
  284  3                      if (N_Pulse<=-30000)
  285  3                              {
  286  4                               N_Pulse=0;
  287  4                               
  288  4                              }
  289  3                      }
  290  2              }
  291  1      else // c'est un front descendant
  292  1              {
  293  2              if (Opto_8==0) // marche avant
  294  2                      {
  295  3                      N_Pulse=N_Pulse+1;
  296  3                      // modulo 30 000
  297  3                      if (N_Pulse>=30000)
  298  3                              {
  299  4                               N_Pulse=0;
  300  4                              
  301  4                              }
  302  3                      }
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 6   

  303  2              else       // marche arrière
  304  2                      {
  305  3                      N_Pulse=N_Pulse-1;
  306  3                      // modulo 30 000
  307  3                      if (N_Pulse<=-30000)
  308  3                              {
  309  4                               N_Pulse=0;
  310  4                               
  311  4                              }
  312  3                      }
  313  2              }
  314  1      }
  315         
  316         int Lire_Position(void)
  317         {
  318  1              return N_Pulse;
  319  1      }
  320         
  321         
  322         void Init_Position(int Position_Initiale)
  323         {
  324  1              N_Pulse=Position_Initiale;
  325  1      }
  326         
  327         
  328         
  329         
  330         //______________________________________________________________________________________________
  331         
  332         void Config_PWM(void)    // P7.1 
  333         {
  334  1      // PWM1 validée, Clk à 20MHz => si on prend un PT1=1024, on est à 20kHz de découpage
  335  1      // 
  336  1      // PWMCON0 = xxxx xx0x xx0x xx0x 
  337  1      // PWMCON1 = xxx0 xxxx xx0x xx1x
  338  1      PWMCON0=PWMCON0&0xFDDD;
  339  1      PWMCON1=PWMCON1&0xEFDF;
  340  1      PWMCON1=PWMCON1|0x0002;
  341  1      
  342  1      PT1=0;  // le timer à 0
  343  1      PW1=0;  // au depart, duty = 0
  344  1      PP1=1024; // période qui donnera environ 20k
  345  1      
  346  1      
  347  1      /* Configuration PORT7.1 en sortie pushpull     */       
  348  1      // ODP7.1 = 0, 
  349  1      ODP7=ODP7&0XFFFD;
  350  1      // DP7.1 =1, bit 1 du port7 en sortie
  351  1      DP7=DP7|0X0002;
  352  1      
  353  1      // P7.1 = 1, pour replacer la PWM en phase (inversion par XOR nécessaire)
  354  1      P7=P7|0X0002;
  355  1      
  356  1      // demarrage timer PWM1 
  357  1      PTR1=1;
  358  1      
  359  1      
  360  1      }
  361         
  362         void Fixe_Rapport(float Sigma)
  363         {
  364  1              float valeur;
C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 7   

  365  1              signed int valeur_entiere;
  366  1      
  367  1              valeur = (512.0*Sigma);
  368  1              // -512.0 à +511.0
  369  1              valeur_entiere = (signed int) valeur;
  370  1              valeur_entiere = valeur_entiere+512;
  371  1              if (valeur_entiere>1023) valeur_entiere=1023;
  372  1              if (valeur_entiere<1) valeur_entiere=1;
  373  1              PW1=valeur_entiere;
  374  1      }
  375         
  376         //_________________________________________LEDS__________________
  377         // initLED avant la première utilisation (inite les LEDS éteintes)
  378         // puis  appel de modifierLed1 ou 2 pour changer son état
  379         
  380          void Init_Led(void){
  381  1              DP2=0x00FF;
  382  1              ODP2=0x00;
  383  1              P2 =   P2 & 0xFF00;
  384  1      }
  385         void Modifier_Led_1(void){
  386  1              P2=P2 ^ 0x01;
  387  1      }
  388         
  389         void Modifier_Led_2(void){
  390  1              P2=P2 ^ 0x02;
  391  1      }        
  392         
  393         void Toggle_Led(unsigned char Num_Led){
  394  1              P2=P2 ^ (1<<Num_Led);
  395  1      }
  396         
  397         void Set_Led(unsigned char Num_Led){
  398  1              P2=P2 | (1<<Num_Led);
  399  1      }
  400         
  401         void Reset_Led(unsigned char Num_Led){
  402  1              P2=P2 & ~(1<<Num_Led);
  403  1      }
  404         //______________________________________________________________________________________________
  405         
  406         
  407         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         494     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =           2     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.

C166 COMPILER V6.08, DRIVEURS_2007A                                                        12/11/2008 08:49:48 PAGE 8   


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
