C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE TPL_MACHINE_C166
OBJECT MODULE PLACED IN .\objs\tpl_machine_c166.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\..\trampoline-1.1\os\os_machine\c166\tpl_machine_c166.c TI
                    -NY BROWSE INCDIR(.\archi_appli;..\..\..\trampoline-1.1\os;..\..\..\trampoline-1.1\com;..\..\..\trampoline-1.1\os\os_mach
                    -ine\c166;..\..\..\trampoline-1.1\goil\templates\c166;..\..\..\trampoline-1.1\debug) MOD167 DEFINE(WITH_COMPILER_SETTINGS
                    -) DEBUG PRINT(.\tpl_machine_c166.lst) OBJECT(.\objs\tpl_machine_c166.obj) 

 stmt lvl     source

    1         /*
    2          * Trampoline OS
    3          *
    4          * Trampoline is copyright (c) IRCCyN 2005+
    5          * Trampoline est prot��par la loi sur la propri��intellectuelle
    6          *
    7          * This software is distributed under the Lesser GNU Public Licence
    8          *
    9          * Trampoline C166 specifics
   10          *
   11          * $Date:$
   12          * $Rev$
   13          * $Author$
   14          * $URL$
   15          */
   16         
   17         #include "tpl_machine.h"
   18         #include "tpl_os_application_def.h"   /* NO_ALARM */
   19         #include "tpl_os_generated_configuration.h"        /* TASK_COUNT and ISR_COUNT*/
   20         #include "tpl_os_definitions.h" /* IS_ROUTINE  */
   21         #include "tpl_os_internal_types.h" /*struct tpl_task*/ //ACCO
   22         #include <C167CS.H>     /*TODO: update with a more generic standard include file.*/
   23         
   24         
   25         #pragma warning disable = 47 /* disables the "unreferenced parameter" warning */
   26                                                                  /* used for the tpl_switch_context function      */
   27         
   28         
   29         c166_context idle_task_context;
   30         
   31         
   32         #define SMALL_MEMORY_MODEL
   33         
   34         #ifdef SMALL_MEMORY_MODEL
   35         /* use a register bank for interrupts and in the context switch function */
   36         unsigned int idata registers_it[16];
   37         unsigned int idata registers_c166[TASK_COUNT+ISR_COUNT+1][16];
   38         
   39         /*
   40          * tpl_sleep is used by the idle task
   41          */
   42         void tpl_sleep(void)
   43         {
   44  1              while(1);
   45  1      /*      __asm {
   46  1                      IDLE
   47  1              }
   48  1      */
   49  1      }
   50         
   51         void tpl_shutdown(void)
   52         {
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 2   

   53  1              /* remove ITs */
   54  1              IEN = 0;
   55  1              /* TODO: update to set idle mode.*/
   56  1              while (1); 
   57  1      }
   58         
   59         void tpl_switch_context(tpl_context *old_context, tpl_context *new_context)
   60         {
   61  1              
   62  1              /* Only works with a near memory model.
   63  1               *  
   64  1               * R8 has a pointer to the old context.
   65  1               * R9 has a pointer to the new context.
   66  1               * first of all: store the current context in old_context
   67  1               * R1 stores DPP3 of the context we're working on 
   68  1               * R5 stores the context we're working on
   69  1               * R2 stores intermediate values (IP, stack)
   70  1               * R3 stores the old CP 
   71  1               */
   72  1              __asm {
   73  1              PUSH CP /*store the current register bank */
   74  1              MOVW CP, #registers_it
   75  1              NOP /* pipeline effect */
   76  1              POP R3 /* the old CP */
   77  1              /* store DPP3 on R1 */
   78  1              MOVW R1, DPP3
   79  1              MOVW DPP3, #3
   80  1              NOP
   81  1              MOVW R0, [R3] //R0 in user stack.
   82  1              MOVW R8, [R3+#16]
   83  1              MOVW R9, [R3+#18]
   84  1              #ifdef LARGE_POINTER 
                              /* pointer does not fill in only one 16 bit register*/
                              MOVW R10,[R3+#20] 
                              MOVW R11,[R3+#22]
                      #endif
   89  1              /*ok, now, all the other registers may be changed. */
   90  1              /* if old_context */
   91  1              CMP R8,#0
   92  1              JMPR CC_Z,NO_OLD_CONTEXT_TO_SAVE
   93  1                              /* R5 get the context */
   94  1                              MOVW R5,[R8]
   95  1                      
   96  1                              MOVW [R5],MDC   /* store mdc  */
   97  1                              ADD R5,#2       
   98  1                              MOVW [R5],DPP0  /* store dpp0 */
   99  1                              ADD R5,#2
  100  1                              MOVW [R5],DPP1  /* store dpp1 */
  101  1                              ADD R5,#2
  102  1                              MOVW [R5],DPP2  /* store dpp2 */
  103  1                              ADD R5,#2
  104  1                              MOVW [R5],R1    /* store dpp3 */
  105  1                              ADD R5,#2
  106  1                              MOVW [R5],MDH   /* store mdh */
  107  1                              ADD R5,#2
  108  1                              MOVW [R5],MDL   /* store mdl */
  109  1                              POP R2          /*R2 get return ip*/
  110  1                              ADD R5,#2
  111  1                              MOVW [R5],SP    /* store sp */
  112  1                              ADD R5,#2
  113  1                              MOVW [R5],STKOV /* store stkov */
  114  1                              ADD R5,#2
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 3   

  115  1                              MOVW [R5],STKUN /* store stkun */
  116  1                              ADD R5,#2
  117  1                              MOVW [R5],PSW   /* store psw */
  118  1                              ADD R5,#2
  119  1                              MOVW [R5],CSP   /* store csp */
  120  1                              ADD R5,#2
  121  1                              MOVW [R5],R2    /* store ip */
  122  1                              ADD R5,#2
  123  1                              MOVW [R5],R3    /* store cp */
  124  1                              ADD R5,#2
  125  1                              MOVW [R5],R0    /* store user stack */
  126  1      NO_OLD_CONTEXT_TO_SAVE:
  127  1                      /* then set the new context */
  128  1                      MOVW R5, [R9] /*the new context */
  129  1                      MOVW MDC, [R5]  /* restore mdc */
  130  1                      ADD R5,#2
  131  1                      MOVW DPP0, [R5] /* restore dpp0 */
  132  1                      ADD R5,#2           /* no dpp use allowed after writing in DPPx, pipeline effect */
  133  1                      MOVW DPP1, [R5] /* restore dpp1 */
  134  1                      ADD R5,#2
  135  1                      MOVW DPP2, [R5] /* restore dpp2 */
  136  1                      ADD R5,#2
  137  1                      MOVW R1, [R5]   /* get the dpp3 to restore at the end.*/
  138  1                      ADD R5,#2
  139  1                      MOVW MDH, [R5]  /* restore mdh */
  140  1                      ADD R5,#2
  141  1                      MOVW MDL, [R5]  /* restore mdl */
  142  1                      /* no exception after a stkov or stkun change.
  143  1                       * only after a sp change -> not true with the monitor.
  144  1                       */
  145  1      
  146  1                      MOVW R2,#0xf200   /*low limit of iram -> stkov. */
  147  1                      MOVW STKOV,R2   
  148  1                      MOVW R2,#0xfdfe   /*high limit of iram -> stkun */
  149  1                      MOVW STKUN,R2
  150  1      
  151  1                      /* then set the new sp */
  152  1                      ADD R5,#2
  153  1                      MOVW SP, [R5]   /* restore sp ********* STACK CHANGE **********/
  154  1                      ADD R5,#2
  155  1                      MOVW STKOV, [R5]        /* restore stkov */
  156  1                      ADD R5,#2
  157  1                      MOVW STKUN, [R5]        /* restore stkun */
  158  1      
  159  1                      /* store PSW, CSP and IP on top of the stack -> RETI*/
  160  1                      ADD R5,#2
  161  1                      MOVW R2, [R5]   /* get PSW */
  162  1                      PUSH R2         /* store in stack */
  163  1                      ADD R5,#2
  164  1                      MOVW R2, [R5]   /* get CSP */
  165  1                      PUSH R2         /* store in stack */
  166  1                      ADD R5,#2
  167  1                      MOVW R2, [R5]   /* get IP */
  168  1                      PUSH R2         /* store in stack */
  169  1      
  170  1                      ADD R5,#2
  171  1                      MOVW R2, [R5] //R2 <- CP of the new task
  172  1                      ADD R5,#2
  173  1                      MOVW [R2], [R5] //init R0 of the new task.
  174  1                      PUSH R1                 /*store DPP3 on stack */
  175  1                      MOVW CP, R2     /* restore cp */
  176  1                      /* Warning next instruction MUST NOT use GPRs!!! (pipeline effect) */
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 4   

  177  1                      POP DPP3                /* restore DPP3 */
  178  1                      /* the next "reti" instruction will pop the IP, CSP and PSW registers */
  179  1                      RETI
  180  1              }
  181  1      }
  182         
  183         void tpl_switch_context_from_it(tpl_context * old_context, tpl_context * new_context)
  184         {
  185  1              /* Only works with a near memory model.
  186  1               * current register bank is registers_it
  187  1               * R8 has a pointer to the old context.
  188  1               * R9 has a pointer to the new context.
  189  1               * DPP3 = 3 (value set in interrupt handler).
  190  1               * first of all: store the current context in old_context
  191  1               */
  192  1              __asm {
  193  1                      /*don't store context if pointer is NULL. */
  194  1                      CMP R8,#0
  195  1                      JMPR CC_Z,NO_OLD_CONTEXT_TO_SAVE_IT
  196  1                      /* R1, R2 used to get values from the stack (see documentation). */
  197  1                      /* R5 used to get fields in the context. */
  198  1      
  199  1                              MOVW R5,[R8]            /* init*/
  200  1                              MOVW R1,0xfe12   
  201  1      
  202  1                              MOVW [R5], MDC  /* store mdc  */
  203  1                              
  204  1                              MOVW R2, [R1+#14]
  205  1                              ADD R5,#2
  206  1                              MOVW [R5],R2            /* store dpp0 */
  207  1                              
  208  1                              ADD R5,#2
  209  1                              MOVW [R5],DPP1  /* store dpp1 */
  210  1                              ADD R5,#2
  211  1                              MOVW [R5],DPP2  /* store dpp2 */
  212  1      
  213  1                              MOVW R2, [R1+#18]
  214  1                              ADD R5,#2
  215  1                              MOVW [R5],R2            /* store dpp3 */
  216  1                              
  217  1                              ADD R5,#2
  218  1                              MOVW [R5],MDH           /* store mdh */
  219  1      
  220  1                              ADD R5,#2
  221  1                              MOVW [R5],MDL           /* store mdl */
  222  1                              
  223  1                              MOVW R2, R1              
  224  1                              ADD R2, #26
  225  1                              ADD R5,#2
  226  1                              MOVW [R5],R2             /* store sp */
  227  1                              
  228  1                              ADD R5,#2
  229  1                              MOVW [R5],STKOV /* store stkov */
  230  1                              ADD R5,#2
  231  1                              MOVW [R5],STKUN /* store stkun */
  232  1      
  233  1                              MOVW R2, [R1+#24]
  234  1                              ADD R5,#2
  235  1                              MOVW [R5],R2            /* store psw */
  236  1      
  237  1                              MOVW R2, [R1+#22]
  238  1                              ADD R5,#2
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 5   

  239  1                              MOVW [R5],R2            /* store csp */
  240  1      
  241  1                              MOVW R2, [R1+#20]
  242  1                              ADD R5,#2
  243  1                              MOVW [R5],R2            /* store ip */
  244  1      
  245  1                              MOVW R2, [R1+#16]
  246  1                              ADD R5,#2
  247  1                              MOVW [R5],R2    /* store cp */
  248  1                      
  249  1                              ADD R5,#2
  250  1                              MOVW [R5],R0    /* store user stack */
  251  1      NO_OLD_CONTEXT_TO_SAVE_IT:                      
  252  1              /* then set the new context */
  253  1                      MOVW R5, [R9] /*the new context */
  254  1                      MOVW MDC, [R5]  /* restore mdc */
  255  1                      ADD R5,#2
  256  1                      MOVW DPP0, [R5] /* restore dpp0 */
  257  1                      ADD R5,#2           /* no dpp use allowed after writing in DPPx, pipeline effect */
  258  1                      MOVW DPP1, [R5] /* restore dpp1 */
  259  1                      ADD R5,#2
  260  1                      MOVW DPP2, [R5] /* restore dpp2 */
  261  1                      ADD R5,#2
  262  1                      MOVW R1, [R5]   /* get the dpp3 to restore at the end.*/
  263  1                      ADD R5,#2
  264  1                      MOVW MDH, [R5]  /* restore mdh */
  265  1                      ADD R5,#2
  266  1                      MOVW MDL, [R5]  /* restore mdl */
  267  1                      /* no exception after a stkov or stkun change.
  268  1                       * only after a sp change -> not true with the monitor.
  269  1                       */
  270  1      
  271  1                      MOVW R2,#0xf200   /*low limit of iram -> stkov. */
  272  1                      MOVW STKOV,R2   
  273  1                      MOVW R2,#0xfdfe   /*high limit of iram -> stkun */
  274  1                      MOVW STKUN,R2
  275  1      
  276  1                      /* then set the new sp */
  277  1                      ADD R5,#2
  278  1                      MOVW SP, [R5]   /* restore sp ********* STACK CHANGE **********/
  279  1                      ADD R5,#2
  280  1                      MOVW STKOV, [R5]        /* restore stkov */
  281  1                      ADD R5,#2
  282  1                      MOVW STKUN, [R5]        /* restore stkun */
  283  1      
  284  1                      /* store PSW, CSP and IP on top of the stack -> RETI*/
  285  1                      ADD R5,#2
  286  1                      MOVW R2, [R5]   /* get PSW */
  287  1                      PUSH R2         /* store in stack */
  288  1                      ADD R5,#2
  289  1                      MOVW R2, [R5]   /* get CSP */
  290  1                      PUSH R2         /* store in stack */
  291  1                      ADD R5,#2
  292  1                      MOVW R2, [R5]   /* get IP */
  293  1                      PUSH R2         /* store in stack */
  294  1      
  295  1                      ADD R5,#2
  296  1                      MOVW R2, [R5] //R2 <- CP of the new task
  297  1                      ADD R5,#2
  298  1                      MOVW [R2], [R5] //init R0 of the new task.
  299  1                      PUSH R1                 /*store DPP3 on stack */
  300  1                      MOVW CP, R2     /* restore cp */
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 6   

  301  1                      /* Warning next instruction MUST NOT use GPRs!!! (pipeline effect) */
  302  1                      POP DPP3                /* restore DPP3 */
  303  1                      /* the next "reti" instruction will pop the IP, CSP and PSW registers */
  304  1                      RETI
  305  1              }
  306  1      }
  307         #endif
  308         
  309         /*
  310          * tpl_init_context initialize a context to prepare a task to run.
  311          * WARNING: This function MUST NOT modify GPRs!!! (the task in parameter
  312          * can be the running one!!!)
  313          */
  314         void tpl_init_context(tpl_task *task)
  315         {
  316  1              int i;
  317  1              int objId;
  318  1      
  319  1              /* Gets a pointer to the static descriptor of the task whose context is going to be inited */
  320  1              tpl_exec_static * static_desc = task->exec_desc.static_desc;
  321  1      
  322  1              /* Gets a pointer to the context going to be initialized */
  323  1              c166_context *ic = static_desc->context.ic;
  324  1      
  325  1              /* find id of the tpl_exec_obj  */
  326  1              objId = static_desc->id;
  327  1          if (static_desc->type & IS_ROUTINE) objId += TASK_COUNT;
  328  1      
  329  1              /* CP init */
  330  1              ic->cp = (unsigned int)&(registers_c166[objId + 1][0]);
  331  1      
  332  1              /* Init of the system stack and storage of the task's entry point address on system stack */
  333  1              ic->stkun = ((unsigned int)(static_desc->stack.sys_stack_zone)) + 
  334  1                                      static_desc->stack.sys_stack_size;
  335  1              ic->stkov = (unsigned int)(static_desc->stack.sys_stack_zone);
  336  1              /* 6 bytes reserved to push the init value of IP/CSP/PSW on the stack 
  337  1               * the context switch uses the RETI instruction to switch to the task function.
  338  1               */
  339  1              ic->sp =        ic->stkun - 3*sizeof(unsigned int);
  340  1              /* pushes entry point on stack */
  341  1              ic->psw = 0x0800;
  342  1              ic->csp = (unsigned int)(((unsigned long)(static_desc->entry)) >> 16); 
  343  1              ic->ip = (unsigned int)(static_desc->entry); 
  344  1              /* Init of the user stack :  R0 = upper address of the user stack zone */
  345  1              ic->ustack = (unsigned int)(static_desc->stack.user_stack_zone) + 
  346  1                                                                              static_desc->stack.user_stack_size;  
  347  1              /* Init Others to 0 */
  348  1              ic->mdh = 0;
  349  1              ic->mdl = 0;
  350  1          /* Init DPPx registers */
  351  1      #ifdef SMALL_MEMORY_MODEL
  352  1              ic->dpp0 = DPP0;
  353  1      #else
                      ic->dpp0 = (unsigned int)((unsigned long)ic >> 14);
              #endif
  356  1              ic->dpp1 = DPP1;
  357  1              ic->dpp2 = DPP2;
  358  1              ic->dpp3 = DPP3;
  359  1      }
  360         
  361         
  362         
C166 COMPILER V6.08, TPL_MACHINE_C166                                                      06/28/2009 16:38:41 PAGE 7   

  363         void tpl_get_task_lock(void)
  364         {
  365  1              IEN = 0;
  366  1      }
  367         
  368         void tpl_release_task_lock(void)
  369         {
  370  1              IEN = 1;
  371  1      }
  372         
  373         /*
  374          * tpl_init_machine 
  375          */
  376         void tpl_init_tick_timer();
  377         void tpl_init_machine(void)
  378         {
  379  1              #ifndef NO_ALARM
  380  1                      tpl_init_tick_timer();
  381  1              #endif
  382  1      }
  383         
*** RETI
*** ^
*** WARNING C195 IN LINE 179 OF ..\..\..\trampoline-1.1\os\os_machine\c166\tpl_machine_c166.c: inline-asm: 'near' return
             - in 'far' function
*** RETI
*** ^
*** WARNING C195 IN LINE 304 OF ..\..\..\trampoline-1.1\os\os_machine\c166\tpl_machine_c166.c: inline-asm: 'near' return
             - in 'far' function


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         622     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          30     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =         128     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
