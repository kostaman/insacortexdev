C166 COMPILER V6.06, CISR16X1                                                              12/21/2007 15:13:02 PAGE 1   


C166 COMPILER V6.06, COMPILATION OF MODULE CISR16X1
OBJECT MODULE PLACED IN .\cisr16x1.obj
COMPILER INVOKED BY: C:\Keil\C166\BIN\C166.EXE ..\..\includes\libCAN\cisr16x1.c OPTIMIZE(0,SPEED) BROWSE MOD167 DEFINE(S
                    -TDIO=1,CONTROLLEUR) DEBUG PRINT(.\cisr16x1.lst) OBJECT(.\cisr16x1.obj) 

 stmt lvl     source

    1         /* ----------------------------------------- header: ----------------*/
    2         /*********************************************************************
    3          * ISR name:            "CANIR16X.C"                                 *
    4          * Compiler used:       BSO/Tasking C166                             *
    5          * Task:                CAN ISR for Siemens ApNote AP2922            *
    6          *                      "'C' CAN Driver Routines for the C166 family'*
    7          *                                                                   * 
    8          * Last modifications:  April 29nd 1997                              *
    9          * Authors:             Axel Wolf,  SCI Cupertino                    *
   10          *                      Dr. Jens Barrenscheen, HL MC PD, Munich      *
   11          *********************************************************************/
   12         /* ----------------------------------- include files: -------------- */
   13         #include <REG167.H>          /* register definitions C167            */
   14         #include "CANR_16X.H"       /* CAN control register definitions      */
   15         
   16         #define TEST_IDENTIFIER 0x151   /* Test ID used by example program */
   17         
   18         /* ----------------------------------- externals, prototypes: ------ */
   19         extern void init_can_16x(unsigned int baud_rate, unsigned char eie,
   20                 unsigned char sie, unsigned char ie);
   21                 /* Initialization of CAN-Module: (baud_rate, eie, sie, ie) */
   22         extern void def_mo_16x(unsigned char nr, unsigned char xtd, unsigned long id,
   23                 unsigned char dir, unsigned char dlc, unsigned char txie,
   24                 unsigned char rxie);
   25                 /* Define message object: MO-number, xtd, id, dir, dlc, TXIE, RXIE */
   26         extern void ld_modata_16x(unsigned char nr, unsigned char *upl_data_ptr);
   27                 /* load data bytes of a message object (1..14) */
   28         extern void rd_modata_16x(unsigned char nr, unsigned char *downl_data_ptr);
   29                 /* read data bytes from message object 'nr' (1..14) */
   30         extern void rd_mo15_16x(unsigned char *mo15_db_ptr,
   31                 unsigned long *mo15_id_ptr, unsigned char *mo15_dlc_ptr);
   32                 /* read dlc, identifier and data from MO 15 of C167 (Basic CAN) */
   33         extern void send_mo_16x(unsigned char nr);
   34                 /* Transmit message object 'nr' (1..14) */
   35         extern unsigned char check_mo_16x(unsigned char nr);
   36                 /* check for new data in MO 'nr' (1..14) and if so, return 1 */
   37         extern unsigned char check_mo15_16x(void);
   38                 /* check for new data or remote frame in MO 15 and if so, return 1 */
   39         extern unsigned char check_busoff_16x(void);
   40                 /* check for bus off situation and recover if necessary */
   41         
   42         
   43         interrupt(0x40)         /* trap number (see C167 manual, 5-3)        */
*** ERROR C25 IN LINE 43 OF ..\..\INCLUDES\LIBCAN\CISR16X1.C: syntax error near 'interrupt'
*** ERROR C25 IN LINE 43 OF ..\..\INCLUDES\LIBCAN\CISR16X1.C: syntax error near '0x40'
   44         void ISR_2 (void); 
   45         /* ----------------------------------- PEC, Register: -------------- */
   46         /* ----------------------------------- global  byte/word data: ----- */
   47         /* ----------------------------------- global  bit data: ----------- */
   48         /* ----------------------------------- interrupt routine: ---------- */
   49         interrupt(0x40)              /* CAN Module IR */
*** ERROR C25 IN LINE 49 OF ..\..\INCLUDES\LIBCAN\CISR16X1.C: syntax error near 'interrupt'
*** ERROR C25 IN LINE 49 OF ..\..\INCLUDES\LIBCAN\CISR16X1.C: syntax error near '0x40'
   50         /* ----------------------------------- code: main program: --------- */
C166 COMPILER V6.06, CISR16X1                                                              12/21/2007 15:13:02 PAGE 2   

   51         void ISR_2 (void)
   52         {
   53  1         /* -------------------------------- local  byte/word/bit data: -- */
   54  1         unsigned char status, intid;
   55  1         unsigned char download_data_buf[8]={0,0,0,0,0,0,0,0};
   56  1         unsigned char buf_no=0;              /* contains actual MO 15 buffer (0/1)*/
   57  1         unsigned char mo15_db_buf[2][8]={{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}};
   58  1                                              /* storage for MO15 buffer 1/2 data */
   59  1         unsigned long mo15_id[2]={0,0};      /* storage for MO15 buffer 1/2 id */ 
   60  1         unsigned char mo15_dlc[2]={0,0};     /* storage for MO15 buffer 1/2 dlc */
   61  1         /* -------------------------------- program: -------------------- */
   62  1      while (intid=IR)        /* reload intid with IR, continue loop if intid != 0 */
   63  1         {
   64  2            status=SR;        /* copy status register to status variable */
   65  2            SR=0;             /* clear status register */
   66  2            switch (intid)
   67  2            {
   68  3              case 1:                         /* Status Change Interrupt */
   69  3                 if (CR & 0x04)               /* if SIE is set (status interrupts) */
   70  3                 {
   71  4                      if (status & 0x08) {}   /* transmit interrupt */
   72  4                      if (status & 0x10) {}   /* receive interrupt */
   73  4                      if (status & 0x07) {}   /* CAN bus error interrupt */
   74  4                 }
   75  3                 if (CR & 0x08)               /* if EIE is set (error interrupts) */
   76  3                 {
   77  4                      if (status & 0x40) {}   /* error counter warning */
   78  4                      if (status & 0x80)      /* bus off situation */
   79  4                         CR = (CR & 0xfe);    /* recover from BOFF (clear INIT) */
   80  4                 }
   81  3                 break;
   82  3      
   83  3              case 2:                         /* Message 15 receive Interrupt */
   84  3                 rd_mo15_16x(mo15_db_buf[buf_no],&mo15_id[buf_no],&mo15_dlc[buf_no]);
   85  3                              /* read id, dlc & data from MO 15, reset INTPND */
   86  3      
   87  3                 if (mo15_id[buf_no]==TEST_IDENTIFIER)
   88  3                 {
   89  4                      def_mo_16x(14, 0, mo15_id[buf_no], 1, mo15_dlc[buf_no], 0, 0);
   90  4                         /* Define message object 14 for data frame transmission */
   91  4                         /* MO=14,xtd=no,id=MO15,dir=tr,dlc=MO15,TXIE=no,RXIE=no */
   92  4      
   93  4                      ld_modata_16x(14, mo15_db_buf[buf_no]);
   94  4                         /* load data bytes of MO14 with data just read from MO 15 */
   95  4      
   96  4                      send_mo_16x(14); /* Transmit message 14 (sends data frame) */
   97  4                 }
   98  3      
   99  3                 if (buf_no==0) buf_no=1; else buf_no=0;   /* swap MO15 buffer # */
  100  3                 break;
  101  3      
  102  3              case 3:                         /* Message 1 Interrupt */
  103  3                 if (status & 0x10)           /* if receive interrupt... (RXOK=1)*/  
  104  3                 {
  105  4                      /* whatever you want to do, but first you have to */
  106  4                      /* enable Message Object 1 for the generation of */
  107  4                      /* receive interrupts (MO1_RXIE_BIT = 1 in MAIN) */
  108  4                 }
  109  3                 if (status & 0x08)           /* if transmit interrupt... (TXOK=1)*/
  110  3                 {
  111  4                      /* whatever you want to do, but first you have to */
  112  4                      /* enable Message Object 1 for the generation of */
C166 COMPILER V6.06, CISR16X1                                                              12/21/2007 15:13:02 PAGE 3   

  113  4                      /* transmit interrupts (MO1_TXIE_BIT = 1 in MAIN) */
  114  4                 }
  115  3                 break;
  116  3      
  117  3              case 4:                         /* Message 2 Interrupt */
  118  3      
  119  3                 if (status & 0x10)           /* if receive interrupt... (RXOK=1)*/  
  120  3                 {
  121  4                 /* read data, reset INTPND: */
  122  4                      rd_modata_16x(2, download_data_buf);
  123  4                 /* load data bytes of MO 3 with data just read from MO 2: */
  124  4                      ld_modata_16x(3, download_data_buf);
  125  4                 /* Transmit message 3 (sends data frame): */
  126  4                      send_mo_16x(3);
  127  4                 }
  128  3                 if (status & 0x08){}         /* if transmit interrupt... (TXOK=1)*/
  129  3                 break;
  130  3      
  131  3              case 5:                         /* Message 3 Interrupt */
  132  3                 if (status & 0x10){} /* if receive interrupt... (RXOK=1)*/  
  133  3                 if (status & 0x08){} /* if transmit interrupt... (TXOK=1)*/
  134  3                 break;
  135  3              case 6:                         /* Message 4 Interrupt */
  136  3                 if (status & 0x10){} /* if receive interrupt... (RXOK=1)*/  
  137  3                 if (status & 0x08){} /* if transmit interrupt... (TXOK=1)*/
  138  3                 break;
  139  3      
  140  3              /* ..... */
  141  3      
  142  3              case 16:                        /* Message 14 Interrupt */
  143  3                 if (status & 0x10){} /* if receive interrupt... (RXOK=1)*/  
  144  3                 if (status & 0x08){} /* if transmit interrupt... (TXOK=1)*/
  145  3                 break;
  146  3            }
  147  2         }
  148  1      /*------------------------------------ end: --------------------- */
  149  1      }

C166 COMPILATION COMPLETE.  0 WARNING(S),  4 ERROR(S)
