/* Analog0(float Maxi)
* Simule la dynamique d'une Rame de métro :
*  entrée du modèle : 
*    Vin : valeur du delta en volts à l'entrée de la carte courant provoquée
*         par le signal PWM du PORT7.1
*    Vin[+/-4V] = +4V quand PORT7.1=1
*                 -4V quand PORT7.1=0 
*  sortie du modèle	:
*    Vtach : la vitesse vue du côté de la géné tachy. Channel 5 de l'ADC AIN5
*    OptoA,OptoB : les signaux des opto-coupleurs vues sur P2.8 et P2.9 
*  variables locales :
*    vitesse : vitesse linéaire de la trottinette
*    angle : l'angle en metre ;-) de la roue
*/

/* Modèle continu
    V(m/s)		    K		
  __________  = __________ 
  
  Vin(volts)	 1 + Tau.p	

 Mais Tau est très grand !!! (pas de frottement) donc on prend un simple modèle	intégrateur

 Vtachy(volt)	  1		   V(m/s)			   1		  1
  __________  =  ___  =>  ____________  = ___________ = _____
  
  Vin(volts)	 Tm.p	   Vin(volts)	   Ktach.Tm.p	Tau.p


*/ 


/* Modèle discret de la rame  pour un premier oprdre
                                  -1
      K		bilinéaire		1  + z					   K				 1 - 2.Tau/Te
  __________ =====> K0 . _____________  avec K0 = _____________  et b1 = ______________ 
                                     -1
  1 + Tau. P			   1  + b1. z			   1 + 2.Tau/Te		  1 + 2.Tau/Te

d'où 
y[k] = -b1.y[k-1] + K0.(e[k]+e[k-1])

Pour un modèle intégrateur méthode d'Euler
y[k] = y[k-1] + Te / Tau * e[k] 


*/
Signal void Ma_Rame (void)
{ 
		float Te,Tm,K,Tau,K0,b1,VitMax,Ktach,Circonf,DemiPas,vitesse,angle,Vin,VinVioke;
		unsigned char int_angle;
		unsigned long int Per,alpha;
		unsigned long int i,cycl;
		signed int OptoA,OptoB;

		Per=100;
		alpha=10;
		Te = (float)Per*alpha/CLOCK;
	    printf("Per=%d",Per);
		printf("Te=%f\n",Te);

		// Pour un premier ordre
		//K = ?;
		//Tau = ?;
		//K0 = K/(1+2*Tau/Te);
		//b1 = (1-2*Tau/Te)/(1+2*Tau/Te);
		//printf("K=%f\n",K);
		//printf("Tau=%f\n",Tau);
		//printf("K0=%f\n",K0);
		//printf("b1=%f\n",b1);

		//pour un intrégrateur pur
		Tm = 33.5E-3;

		VitMax = (12.0 * 1000.0) /60.0 /60.0;
		Ktach = 2.5/VitMax;
		printf("Ktach=%f\n",Ktach);

		Circonf = 0.13*3.14;
		DemiPas = Circonf/96;//46 bandes soit 96 fronts sur A et B confondus par tour
		printf("Demi_Pas=%f\n",DemiPas);
	
	

		vitesse = 0.0;
		VinVioke=0.0;
		angle=0.0;
		AIN5=2.5;
		OptoA=0;
		OptoB=0;

		while (1) {

			//1 calcul de la moyenne de la sortie PWM sur une période Te
			cycl=0;
			for(i=0;i<Per;i++)
			{
				twatch(alpha);
				cycl = cycl + alpha*(PORT7 && 2);
			  
			   //1 Calcul de l'angle et génération des optos
			angle  =  angle + vitesse * (float)alpha /(float)CLOCK;
	 		int_angle = (signed char)((float)(angle/DemiPas));
		    if ((int_angle & 2)>1) PORT2 = PORT2 | (1<<8);	 
			else PORT2 = PORT2 & ~(1<<8);
			int_angle--;
			if ((int_angle & 2)>1) PORT2 = PORT2 | (1<<9);
			else PORT2 = PORT2 & ~(1<<9);
	
			} //boucle rapide


			
			VinVioke=Vin;
			Vin = 2.0 * 4.0 * (float)cycl/(float)Per / (float)alpha -4.0;
			//printf("Vin=%f       cycl=%d\n",Vin,cycl);
	
			//1 Calcul de la récurrence d evitesse
			//Pour un premier ordre
			//vitesse = -b1 * vitesse + K0 * (Vin+VinVioke) ;
			
			//Pour un intégrateur pur
			vitesse = vitesse + Te/Tm/Ktach*Vin;

			//1 saturation de la vitesse
			if (Ktach*Vitesse>2.5) vitesse=2.5/Ktach;
			if (Ktach*vitesse<-2.5) vitesse=-2.5/Ktach;

			AIN5 = Ktach * vitesse + 2.5;

			
		
		}
}
KILL button *
define button "Lance Rame","Ma_Rame()"
define button "VcomI","LA PORT7 & 2" 
define button "Vtachy","LA AIN5" 
define button "VOptos","LA PORT2 & (1<<8);LA PORT2 & (1<<9)"
