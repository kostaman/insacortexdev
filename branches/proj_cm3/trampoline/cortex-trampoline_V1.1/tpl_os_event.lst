C166 COMPILER V6.08, TPL_OS_EVENT                                                          06/28/2009 16:38:39 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE TPL_OS_EVENT
OBJECT MODULE PLACED IN .\objs\tpl_os_event.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\..\trampoline-1.1\os\tpl_os_event.c TINY BROWSE INCDIR(.\a
                    -rchi_appli;..\..\..\trampoline-1.1\os;..\..\..\trampoline-1.1\com;..\..\..\trampoline-1.1\os\os_machine\c166;..\..\..\tr
                    -ampoline-1.1\goil\templates\c166;..\..\..\trampoline-1.1\debug) MOD167 DEFINE(WITH_COMPILER_SETTINGS) DEBUG PRINT(.\tpl_
                    -os_event.lst) OBJECT(.\objs\tpl_os_event.obj) 

 stmt lvl     source

    1         /*
    2          * Trampoline OS
    3          *
    4          * Trampoline is copyright (c) IRCCyN 2005+
    5          * Trampoline is protected by the French intellectual property law.
    6          *
    7          * This software is distributed under the Lesser GNU Public Licence
    8          *
    9          * Trampoline Event Management implementation file
   10          *
   11          * $Date: 2007-11-09 14:33:58 +0100 (Fri, 09 Nov 2007) $
   12          * $Rev: 401 $
   13          * $Author: ayrton $
   14          * $URL: https://trampoline.rts-software.org/svn/trunk/os/tpl_os_event.c $
   15          *
   16          */
   17         
   18         #include "tpl_os.h"
   19         #include "tpl_os_error.h"
   20         #include "tpl_os_kernel.h"
   21         #include "tpl_machine_interface.h"
   22         
   23         #include "tpl_os_event.h"
   24         
   25         #define OS_START_SEC_CODE
   26         #include "tpl_memmap.h"
   27         
   28         /*
   29          * SetEvent
   30          */
   31         FUNC(StatusType, OS_CODE) SetEvent(
   32             CONST(TaskType, AUTOMATIC)      task_id,
   33             CONST(EventMaskType, AUTOMATIC) event)
   34         {
   35  1          VAR(StatusType, AUTOMATIC) result = E_OK;
   36  1      
   37  1          LOCK_WHEN_HOOK()
   38  1      
   39  1          STORE_SERVICE(OSServiceId_SetEvent)
   40  1          STORE_TASK_ID(task_id)
   41  1          STORE_EVENT_MASK(event)
   42  1      
   43  1          CHECK_TASK_ID_ERROR(task_id,result)
   44  1      
   45  1          LOCK_WHEN_NO_HOOK()
   46  1      
   47  1          /*  checks the task is an extended one  */
   48  1          CHECK_NOT_EXTENDED_TASK_ERROR(task_id,result)
   49  1          /*  checks the task is not in the SUSPENDED state   */
   50  1          CHECK_SUSPENDED_TASK_ERROR(task_id,result)
   51  1      
   52  1      #ifndef NO_TASK
C166 COMPILER V6.08, TPL_OS_EVENT                                                          06/28/2009 16:38:39 PAGE 2   

   53  1          IF_NO_EXTENDED_ERROR(result)
   54  1              result = tpl_set_event(tpl_task_table[task_id], event);
   55  1              if (result == (tpl_status)E_OK_AND_SCHEDULE)
   56  1              {
   57  2                  tpl_schedule(FROM_TASK_LEVEL);
   58  2                  result &= OSEK_STATUS_MASK;
   59  2              }
   60  1          IF_NO_EXTENDED_ERROR_END()
   61  1      #endif
   62  1      
   63  1          UNLOCK_WHEN_NO_HOOK()
   64  1      
   65  1          PROCESS_ERROR(result)
   66  1      
   67  1          UNLOCK_WHEN_HOOK()
   68  1      
   69  1          return result;
   70  1      }
   71         
   72         
   73         /*
   74          * ClearEvent
   75          * see paragraph 13.5.3.2, page 61 of OSEK spec 2.2.2
   76          */
   77         FUNC(StatusType, OS_CODE) ClearEvent(
   78             CONST(EventMaskType, AUTOMATIC) event)
   79         {
   80  1          VAR(StatusType, AUTOMATIC) result = E_OK;
   81  1      
   82  1          LOCK_WHEN_HOOK()
   83  1      
   84  1          STORE_SERVICE(OSServiceId_ClearEvent)
   85  1          STORE_EVENT_MASK(event)
   86  1      
   87  1          LOCK_WHEN_NO_HOOK()
   88  1          /*  ClearEvent cannot be called from ISR level  */
   89  1          CHECK_TASK_CALL_LEVEL_ERROR(result)
   90  1          /*  checks the calling task is an extended one  */
   91  1          CHECK_NOT_EXTENDED_RUNNING_ERROR(result)
   92  1      
   93  1      #ifndef NO_TASK
   94  1          IF_NO_EXTENDED_ERROR(result)
   95  1              /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
   96  1                  that has the same beginning fields as the struct it is casted to
   97  1                  This allow object oriented design and polymorphism.
   98  1              */
   99  1              ((P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC))tpl_running_obj)->evt_set &= (tpl_event_mask)(~event);
  100  1          IF_NO_EXTENDED_ERROR_END()
  101  1      #endif
  102  1      
  103  1          UNLOCK_WHEN_NO_HOOK()
  104  1      
  105  1          PROCESS_ERROR(result)
  106  1      
  107  1          UNLOCK_WHEN_HOOK()
  108  1      
  109  1          return result;
  110  1      }
  111         
  112         /*
  113          * GetEvent
  114          * see paragraph 13.5.3.3, page 61 of OSEK spec 2.2.2
C166 COMPILER V6.08, TPL_OS_EVENT                                                          06/28/2009 16:38:39 PAGE 3   

  115          */
  116         FUNC(StatusType, OS_CODE) GetEvent(
  117             CONST(TaskType, AUTOMATIC)          task_id,
  118             CONST(EventMaskRefType, AUTOMATIC)  event)
  119         {
  120  1          VAR(StatusType, AUTOMATIC) result = E_OK;
  121  1      
  122  1          LOCK_WHEN_HOOK()
  123  1      
  124  1          STORE_SERVICE(OSServiceId_GetEvent)
  125  1          STORE_TASK_ID(task_id)
  126  1          STORE_EVENT_MASK_REF(event)
  127  1      
  128  1          CHECK_TASK_ID_ERROR(task_id,result)
  129  1      
  130  1          /*  checks the task is an extended one  */
  131  1          CHECK_NOT_EXTENDED_TASK_ERROR(task_id,result)
  132  1          /*  checks the task is not in the SUSPENDED state   */
  133  1          CHECK_SUSPENDED_TASK_ERROR(task_id,result)
  134  1      
  135  1      #ifndef NO_TASK
  136  1          IF_NO_EXTENDED_ERROR(result)
  137  1              *event = tpl_task_table[task_id]->evt_set;
  138  1          IF_NO_EXTENDED_ERROR_END()
  139  1      #endif
  140  1      
  141  1          PROCESS_ERROR(result)
  142  1      
  143  1          UNLOCK_WHEN_HOOK()
  144  1      
  145  1          return result;
  146  1      }
  147         
  148         /*
  149          * WaitEvent
  150          * see $13.5.3.4, page 61-62 of OSEK spec 2.2.2
  151          */
  152         FUNC(StatusType, OS_CODE) WaitEvent(
  153             CONST(EventMaskType, AUTOMATIC) event)
  154         {
  155  1          VAR(StatusType, AUTOMATIC) result = E_OK;
  156  1      
  157  1          LOCK_WHEN_HOOK()
  158  1      
  159  1          STORE_SERVICE(OSServiceId_WaitEvent)
  160  1          STORE_EVENT_MASK(event)
  161  1      
  162  1          LOCK_WHEN_NO_HOOK()
  163  1          /*  WaitEvent cannot be called from ISR level  */
  164  1          CHECK_TASK_CALL_LEVEL_ERROR(result)
  165  1          /*  checks the calling task is an extended one  */
  166  1          CHECK_NOT_EXTENDED_RUNNING_ERROR(result)
  167  1          /*  checks the task does not occupied resource(s)   */
  168  1          CHECK_RUNNING_OWNS_REZ_ERROR(result)
  169  1      
  170  1      #ifndef NO_TASK
  171  1          IF_NO_EXTENDED_ERROR(result)
  172  1          /*  all the evt_wait is overidden.  */
  173  1      
  174  1          /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
  175  1              that has the same beginning fields as the struct it is casted to
  176  1              This allow object oriented design and polymorphism.
C166 COMPILER V6.08, TPL_OS_EVENT                                                          06/28/2009 16:38:39 PAGE 4   

  177  1          */
  178  1          ((P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC))tpl_running_obj)->evt_wait = event;
  179  1          /*  check one of the event to wait is not already set       */
  180  1      
  181  1          /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
  182  1              that has the same beginning fields as the struct it is casted to
  183  1              This allow object oriented design and polymorphism.
  184  1          */
  185  1          if ((((P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC))tpl_running_obj)->evt_set & event) == 0)
  186  1          {
  187  2              /*  no one is set, the task goes in the WAITING state   */
  188  2              tpl_running_obj->state = WAITING;
  189  2              /*  and a rescheduling occurs                           */
  190  2              tpl_schedule(FROM_TASK_LEVEL);
  191  2          }
  192  1          IF_NO_EXTENDED_ERROR_END()
  193  1      #endif
  194  1      
  195  1          UNLOCK_WHEN_NO_HOOK()
  196  1      
  197  1          PROCESS_ERROR(result)
  198  1      
  199  1          UNLOCK_WHEN_HOOK()
  200  1      
  201  1          return result;
  202  1      }
  203         
  204         #define OS_STOP_SEC_CODE
  205         #include "tpl_memmap.h"
  206         
  207         /* End of file tpl_os_event.c */


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         174     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =    --------     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
