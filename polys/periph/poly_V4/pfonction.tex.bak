\chapter{Pointeurs de fonction, ta mère !}

\section{Appel indirect des fonctions}

Extraits de : T. Monteil {\it et al.}, Du langage C au C++, Presses Universitaires du Mirail, 2009.\\

De la même manière que le nom d'un tableau représente l'adresse d'implantation de ce tableau (c'est-à-dire l'adresse de son premier élément), le nom d'une fonction (sans parenthèses) représente l'adresse de cette fonction, plus exactement l'adresse de son point d'entrée. Cette adresse peut être :
\begin{itemize}
	\item attribué à un pointeur (pointeur de fonction), ce qui permet l'appel indirect de cette fonction,
	\item transmise comme paramètre à d'autres fonctions,
	\item placée dans un tableau de pointeurs de fonction.
\end{itemize}

\subsection{Pointeur de fonction}

Un pointeur de fonction est une variable pouvant recevoir l'adresse d'une fonction. Dans la déclaration du pointeur, cette fonction est typée, si bien qu'il ne peut ensuite accepter de recevoir que l'adresse d'une fonction de même type. Voici la forme générale de la déclaration d'un tel pointeur:

\begin{verbatim}
type ( * ptrFct ) (type, type, ...);
\end{verbatim}

Les parenthèses de gauche sont obligatoires, sinon il s'agirait d'une fonction retournant un pointeur.

\subsection{Affectation d'un pointeur de fonction}

Voici comment on affecte l'adresse d'une fonction à un pointeur :

\begin{verbatim}
double ( * Math ) ( int, int, double ) ; /* Pointeur de fonction */
double Racine ( int, int, double ) ; /* Fonction */

Math = Racine ; /* Affectation */
\end{verbatim}

\subsection{Appel de fonction par un pointeur}

Dès qu'un pointeur à reçu l'adresse d'une fonction, on peut appeler celle-ci indirectement selon la forme générale suivante :

\begin{verbatim}
/* définition d'un pointeur */
type ( * ptrFcn ) (type, type, ...);

/* déclaration d'une fonction de même type renvoyé */
type Fonc (type, type, ...);

/* affectation du pointeur */
ptdFcn = Fonc;

/* appel indirect de Fonc() */
(*ptrFcn) (arguments);
\end{verbatim}

Dans le cas présent, les deux instructions ci-dessus sont bien équivalentes à un appel direct de \texttt{Fonc()} (\verb"Fonc (arguments);")
En effet, \texttt{*ptrFcn} a pour valeur \texttt{Fonc}.

\subsection{Passage de fonctions en paramètre}

Il est possible de transmettre une fonction en paramètre d'une fonction appelante. Celle-ci emploie le nom de la fonction appelée sans parenthèses ni arguments à la suite. C'est donc l'adresse du point de lancement de cette fonction qui est empilée. Pareillement, on peut transmettre indirectement une fonction en paramètre grâce à un pointeur sur cette fonction. Dans l'exemple qui suit, \texttt{Fonction()} est appelée deux fois avec deux (adresses de) fonctions différentes passées en argument, et une fois avec un pointeur de fonction :

\begin{verbatim}
int Premiere () ;
int Seconde () ;
int ( * pFonction ) () = Seconde ;

void Fonction (int (* ptrFoncArg) (), int Un , int deux )
{
	/* Corps de Fonction () */
}

/* exemple d'appels */
Fonction ( Premiere, 12, -45);
Fonction ( Seconde, 0, 0);
Fonction ( pFonction, Premiere (), Seconde () );
\end{verbatim}

\section{L'art et la manière... }

Nous voulons offrir le moyen à un développeur d'application de configurer un périphérique sans qu'il est besoin d'en connaître son fonctionnemen. Le code que produit le développeur est uniquement dans la couche application (voir chapitre~\ref{sec:archi}) et il ne peut faire appel qu'à des fonctions de la couche pilote pour manipuler le matériel.

Il se pose alors le problème suivant : comment offrir un service à un développeur d'applications qui lui permette d'exécuter lors d'une interruption une fonction qu'il aura développée ?\\

Par exemple, il souhaite exécuter la fonction :
 \begin{verbatim}
void Ma_Fonction_IT ( void )  /* Couche application */
{
   /* Le code à exécuter pendant l'interruption */
}
\end{verbatim}

Il faut donc que dans le Handler de l'interruption il fasse appel à cette fonction, soit :
 \begin{verbatim}
void XXX_IRQHandler ( void )  /* Couche pilote */
{
  Ma_Fonction_IT ();
}
\end{verbatim}

Or cela ne respecte pas nos règles de codage, puisque le Handler doit faire partie de la couche pilote alors que \texttt{Ma\_foncion\_IT} fait partie de la couche application...

Il n'y a pas de solution miracle, il faut faire un peu de programmation \og avancée \fg ! Ca fait du bien aux neurones... Remarquons au passage que la solution est fournie dans le chapitre~\ref{chap:dyn_stat}.

\begin{center}
\fbox{Si d'autres solutions --- effectives --- sont proposées, nous sommes preneur.}
\end{center}

\subsection{... de s'en servir avec la solution dynamique}
Une première solution consiste à utiliser un pointeur de fonctions et s'écrit :
 \begin{verbatim}
/* Fichier application */
void Ma_Fonction_IT ( void )
{
  /* Le code à exécuter pendant l'interruption */
}

/* à faire dans le main */
Init_Periph(Ma_Fonction_IT);

/* Fichier pilote */
void (* pFnc) (void) ; /* déclaration d'un pointeur de fonction */

void XXX_IRQHandler ( void )
{
  if (pFnc != 0)
    (*pFnc) (); /* appel indirect de la fonction */
}

Init_periph (void (* ptrFonction) (void))
{
  pFnc = ptrFonction; /* affectation du pointeur */
}
\end{verbatim}


\subsection{... de s'en passer avec la solution statique}
Une seconde solution consiste à définir dans un fichier de configuration la fonction à exécuter pendant l'interruption :
 \begin{verbatim}
/* Fichier application */
void Ma_Fonction_IT ( void )
{
  /* Le code à exécuter pendant l'interruption */
}

/* Fichier de configuration */
#ifdef HOOK_ON_XXX
  #define XXX_HOOK_CALL Ma_Fonction_IT ()
#endif

/* Fichier pilote */
#ifdef HOOK_ON_XXX
void XXX_IRQHandler ( void )
{
    XXX_HOOK_CALL ;
}
#end
\end{verbatim}

 \subsection{Quelques commentaires}

Ces deux solutions sont élégantes et permettent de bien séparer les couches application et pilote. Elles ne sont pas strictement identiques au niveau fonctionnel et comportent quelques nuances :
\begin{itemize}
	\item La version dynamique permet de configurer l'interruption à la voler et de la reconfigurer en cours d'exécution.
	\item La version statique nécessite une compilation du fichier pilote et donc de fournir son code, ce qui n'est pas le cas de la version dynamique. De plus, il faut maintenir le fichier de configuration.
	\item La version statique va générer uniquement un Handler s'il y a une fonction a exécuter alors que la version dynamique génère un Handler avec 4 lignes de code, plus une fonction d'initialisation (1 ligne) et son appel du main (1 ligne), ce qui permet d'avoir un code plus compact.
\end{itemize} 