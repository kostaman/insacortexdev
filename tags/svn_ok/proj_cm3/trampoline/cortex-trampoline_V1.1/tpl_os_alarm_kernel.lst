C166 COMPILER V6.08, TPL_OS_ALARM_KERNEL                                                   06/28/2009 16:38:37 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE TPL_OS_ALARM_KERNEL
OBJECT MODULE PLACED IN .\objs\tpl_os_alarm_kernel.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\..\trampoline-1.1\os\tpl_os_alarm_kernel.c TINY BROWSE INC
                    -DIR(.\archi_appli;..\..\..\trampoline-1.1\os;..\..\..\trampoline-1.1\com;..\..\..\trampoline-1.1\os\os_machine\c166;..\.
                    -.\..\trampoline-1.1\goil\templates\c166;..\..\..\trampoline-1.1\debug) MOD167 DEFINE(WITH_COMPILER_SETTINGS) DEBUG PRINT
                    -(.\tpl_os_alarm_kernel.lst) OBJECT(.\objs\tpl_os_alarm_kernel.obj) 

 stmt lvl     source

    1         /**
    2          * @file tpl_os_alarm_kernel.c
    3          *
    4          * @section desc File description
    5          *
    6          * Trampoline Alarm Kernel implementation file
    7          *
    8          * @section copyright Copyright
    9          *
   10          * Trampoline OS
   11          *
   12          * Trampoline is copyright (c) IRCCyN 2005-2007
   13          * Trampoline is protected by the French intellectual property law.
   14          *
   15          * This software is distributed under the Lesser GNU Public Licence
   16          *
   17          * @section infos File informations
   18          *
   19          * $Date$
   20          * $Rev$
   21          * $Author$
   22          * $URL$
   23          */
   24         
   25         #include "tpl_os_definitions.h"
   26         #include "tpl_os_kernel.h"
   27         #include "tpl_os_alarm_kernel.h"
   28         
   29         #define OS_START_SEC_CODE
   30         #include "tpl_memmap.h"
   31         
   32         /*
   33          * tpl_insert_time_obj
   34          * insert a time object in the time object queue of the counter
   35          * it belongs to.
   36          *
   37          * The time object list of a counter is a double-linked list
   38          * and a time object is inserted starting from the
   39          * head of the list
   40          */
   41         FUNC(void, OS_CODE) tpl_insert_time_obj(
   42             P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC) time_obj)
   43         {
   44  1          /*  get the counter                                                     */
   45  1          P2VAR(tpl_counter, OS_APPL_DATA, AUTOMATIC)   counter = time_obj->stat_part->counter;
   46  1          /*  initialize the current time object to the head                      */
   47  1          P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC)  current_to = counter->first_to;
   48  1          /*  initialize the time object that precede the current one to NULL     */
   49  1          P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC)  prev_to = NULL;
   50  1      
   51  1          if (current_to == NULL)
   52  1          {
C166 COMPILER V6.08, TPL_OS_ALARM_KERNEL                                                   06/28/2009 16:38:37 PAGE 2   

   53  2              /*  The time object queue is empty
   54  2                  So the time object is alone in the queue                        */
   55  2              counter->first_to = time_obj;
   56  2              counter->next_to = time_obj;
   57  2              time_obj->next_to = time_obj->prev_to = NULL;
   58  2          }
   59  1          else
   60  1          {
   61  2              /*  The time object queue is not empty
   62  2                  look for the place to insert the alarm                          */
   63  2              while ((current_to != NULL) &&
   64  2                     (current_to->date <= time_obj->date))
   65  2              {
   66  3                  prev_to = current_to;
   67  3                  current_to = current_to->next_to;
   68  3              }
   69  2      
   70  2              time_obj->next_to = current_to;
   71  2              time_obj->prev_to = prev_to;
   72  2      
   73  2              /*  insert the alarm    */
   74  2              if (current_to != NULL)
   75  2              {
   76  3                  current_to->prev_to = time_obj;
   77  3              }
   78  2              if (prev_to != NULL)
   79  2              {
   80  3                  /*  add at the end of the queue or insert                       */
   81  3                  prev_to->next_to = time_obj;
   82  3              }
   83  2              else
   84  2              {
   85  3                  /*  the condition current_to->date <= time_object->date was
   86  3                      false a the beginning of the while. So the time object
   87  3                      have to be added at the head of the time object queue       */
   88  3                  counter->first_to = time_obj;
   89  3              }
   90  2      
   91  2              /*  Update the next_to to point to the newly
   92  2                  inserted time_object if the date of the newly inserted time
   93  2                  object is within the current date and the next_alarm_to_raise
   94  2                  date, taking account the modulo                                 */
   95  2              if (counter->next_to->date < counter->current_date)
   96  2              {
   97  3                  if ((time_obj->date > counter->current_date) ||
   98  3                      (time_obj->date < counter->next_to->date))
   99  3                  {
  100  4                      counter->next_to = time_obj;
  101  4                  }
  102  3              }
  103  2              else
  104  2              {
  105  3                  if ((time_obj->date > counter->current_date) &&
  106  3                      (time_obj->date < counter->next_to->date))
  107  3                  {
  108  4                      counter->next_to = time_obj;
  109  4                  }
  110  3              }
  111  2          }
  112  1      }
  113         
  114         /*
C166 COMPILER V6.08, TPL_OS_ALARM_KERNEL                                                   06/28/2009 16:38:37 PAGE 3   

  115          * tpl_remove_alarm
  116          * remove an alarm from the alarm queue of the counter
  117          * it belongs to.
  118          */
  119         FUNC(void, OS_CODE) tpl_remove_time_obj(
  120             P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC) time_obj)
  121         {
  122  1      
  123  1          P2VAR(tpl_counter, OS_APPL_DATA, AUTOMATIC) counter = time_obj->stat_part->counter;
  124  1      
  125  1          /*  adjust the head of the queue if the
  126  1              removed alarm is at the head            */
  127  1          if (time_obj == counter->first_to)
  128  1          {
  129  2              counter->first_to = time_obj->next_to;
  130  2          }
  131  1          /*  adjust the next alarm to raise if it is
  132  1              the removed alarm                       */
  133  1          if (time_obj == counter->next_to)
  134  1          {
  135  2              counter->next_to = time_obj->next_to;
  136  2          }
  137  1          /*  build the link between the previous and next alarm in the queue */
  138  1          if (time_obj->next_to != NULL)
  139  1          {
  140  2              time_obj->next_to->prev_to = time_obj->prev_to;
  141  2          }
  142  1          if (time_obj->prev_to != NULL)
  143  1          {
  144  2              time_obj->prev_to->next_to = time_obj->next_to;
  145  2          }
  146  1          /*  if the next_alarm_to_raise was pointing to the
  147  1              alarm and the alarm was at the end of the queue
  148  1              next_alarm_to_raise is NULL and must be reset to
  149  1              the first alarm of the queue                        */
  150  1          if (counter->next_to == NULL)
  151  1          {
  152  2              counter->next_to = counter->first_to;
  153  2          }
  154  1      }
  155         
  156         /**
  157          * @internal
  158          *
  159          * tpl_raise_alarm is called by tpl_counter_tick
  160          * when an alarm time object is raised.
  161          *
  162          * @param time_obj  The alarm to raise.
  163          */
  164         FUNC(tpl_status, OS_CODE) tpl_raise_alarm(
  165             P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC) time_obj)
  166         {
  167  1          VAR(tpl_status, AUTOMATIC) result = E_OK;
  168  1      
  169  1          /*  Get the alarm descriptor                            */
  170  1          P2VAR(tpl_alarm_static, OS_APPL_DATA, AUTOMATIC) stat_alarm = (tpl_alarm_static *)time_obj->stat_part;
  171  1          /*  Get the action to perform from the alarm descriptor */
  172  1          P2CONST(tpl_action, OS_APPL_CONST, AUTOMATIC) action_desc = stat_alarm->action;
  173  1      
  174  1          /*  Call the action                                     */
  175  1          result = (action_desc->action)(action_desc) ;
  176  1      
C166 COMPILER V6.08, TPL_OS_ALARM_KERNEL                                                   06/28/2009 16:38:37 PAGE 4   

  177  1          return result;
  178  1      }
  179         
  180         
  181         /*
  182          * tpl_counter_tick is called by the IT associated with a counter
  183          * The param is a pointer to the counter
  184          * It increment the counter tick and the counter value if needed
  185          * If the counter value is incremented, it checks the next alarm
  186          * date and raises alarms at that date.
  187          *
  188          * suggested modification by Seb - 2005-02-01
  189          *
  190          * Update: 2006-12-10: Does not perform the rescheduling.
  191          * tpl_schedule must be called explicitly
  192          */
  193         FUNC(tpl_status, OS_CODE) tpl_counter_tick(
  194             P2VAR(tpl_counter, OS_APPL_DATA, AUTOMATIC) counter)
  195         {
  196  1          P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC)  t_obj;
  197  1          VAR(tpl_expire_func, AUTOMATIC)               expire;
  198  1          VAR(tpl_tick, AUTOMATIC)                      date;
  199  1          VAR(tpl_status, AUTOMATIC)                    need_resched = NO_SPECIAL_CODE;
  200  1      
  201  1          /*  inc the current tick value of the counter   */
  202  1          counter->current_tick++;
  203  1          /*  if tickperbase is reached, the counter is inc   */
  204  1          if (counter->current_tick == counter->ticks_per_base)
  205  1          {
  206  2              date = counter->current_date;
  207  2              if (date == counter->max_allowed_value)
  208  2              {
  209  3                  date = 0;
  210  3              }
  211  2              else
  212  2              {
  213  3                  date++;
  214  3              }
  215  2              counter->current_date = date;
  216  2              counter->current_tick = 0;
  217  2      
  218  2              /*  check if the counter has reached the
  219  2                  next alarm activation date  */
  220  2              t_obj = counter->next_to;
  221  2      
  222  2              while ((t_obj != NULL) && (t_obj->date == date))
  223  2              {
  224  3                  /*  note : time_obj is always the next_to
  225  3                      since removing the time object from the queue will
  226  3                      advance next_to along the queue                     */
  227  3      
  228  3                  /*  get the time object from the queue                  */
  229  3                  tpl_remove_time_obj(t_obj);
  230  3      
  231  3                  /*  raise it    */
  232  3                  expire = t_obj->stat_part->expire;
  233  3                  need_resched |=
  234  3                      (TRAMPOLINE_STATUS_MASK & expire(t_obj));
  235  3      
  236  3                  /*  rearm the alarm if needed   */
  237  3                  if (t_obj->cycle != 0)
  238  3                  {
C166 COMPILER V6.08, TPL_OS_ALARM_KERNEL                                                   06/28/2009 16:38:37 PAGE 5   

  239  4                      /*  if the cycle is not 0,
  240  4                          the new date is computed
  241  4                          by adding the cycle to the current date         */
  242  4                      tpl_tick date = t_obj->date + t_obj->cycle;
  243  4                      if (date > counter->max_allowed_value)
  244  4                      {
  245  5                          date -= counter->max_allowed_value;
  246  5                      }
  247  4                      t_obj->date = date;
  248  4                      /*  and the alarm is put back in the alarm queue
  249  4                          of the counter it belongs to                    */
  250  4                      tpl_insert_time_obj(t_obj);
  251  4                  }
  252  3                  else {
  253  4                      t_obj->state = TIME_OBJ_SLEEP;
  254  4                  }
  255  3      
  256  3                  /*  get the next alarm to raise     */
  257  3                  t_obj = counter->next_to;
  258  3              }
  259  2          }
  260  1          return need_resched;
  261  1      }
  262         
  263         #define OS_STOP_SEC_CODE
  264         #include "tpl_memmap.h"
  265         
  266         /* End of file tpl_alarm_kernel.c */


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =         642     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =    --------     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
