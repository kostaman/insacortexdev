C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 1   


C166 COMPILER V6.08, COMPILATION OF MODULE TPL_OS_KERNEL
OBJECT MODULE PLACED IN .\objs\tpl_os_kernel.obj
COMPILER INVOKED BY: C:\Keil\Evalsoft\C166\BIN\C166.EXE ..\..\..\trampoline-1.1\os\tpl_os_kernel.c TINY BROWSE INCDIR(.\
                    -archi_appli;..\..\..\trampoline-1.1\os;..\..\..\trampoline-1.1\com;..\..\..\trampoline-1.1\os\os_machine\c166;..\..\..\t
                    -rampoline-1.1\goil\templates\c166;..\..\..\trampoline-1.1\debug) MOD167 DEFINE(WITH_COMPILER_SETTINGS) DEBUG PRINT(.\tpl
                    -_os_kernel.lst) OBJECT(.\objs\tpl_os_kernel.obj) 

 stmt lvl     source

    1         /**
    2          * @file tpl_os_kernel.c
    3          *
    4          * @section descr File description
    5          *
    6          * Trampoline kernel structures and functions. These functions are used
    7          * internally by trampoline and should not be used directly.
    8          *
    9          * @section copyright Copyright
   10          *
   11          * Trampoline OS
   12          *
   13          * Trampoline is copyright (c) IRCCyN 2005-2007
   14          * Autosar extension is copyright (c) IRCCyN and ESEO 2007
   15          * Trampoline and its Autosar extension are protected by the
   16          * French intellectual property law.
   17          *
   18          * This software is distributed under the Lesser GNU Public Licence
   19          *
   20          * @section infos File informations
   21          *
   22          * $Date: 2007-11-30 14:24:05 +0100 (Fri, 30 Nov 2007) $
   23          * $Rev: 405 $
   24          * $Author: jlb $
   25          * $URL: https://trampoline.rts-software.org/svn/trunk/os/tpl_os_kernel.c $
   26          *
   27          */
   28         
   29         #include "tpl_os_kernel.h"
   30         #include "tpl_os_definitions.h"
   31         #include "tpl_os_hooks.h"
   32         #include "tpl_os_alarm_kernel.h"
   33         #include "tpl_machine.h"
   34         #include "tpl_machine_interface.h"
   35         #include "tpl_dow.h"
   36         
   37         #ifdef WITH_AUTOSAR_STACK_MONITORING
              #include "tpl_as_stack_monitor.h"
              #endif
   40         #ifdef WITH_AUTOSAR
              #include "tpl_as_st_kernel.h"
              #endif
   43         
   44         #define OS_START_SEC_CODE
   45         #include "tpl_memmap.h"
   46         
   47         _STATIC_ /*@null@*/
   48         FUNC(P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC), OS_CODE)
   49         tpl_get_exec_object(void);
   50         
   51         #define OS_STOP_SEC_CODE
   52         #include "tpl_memmap.h"
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 2   

   53         
   54         
   55         #define OS_START_SEC_VAR_UNSPECIFIED
   56         #include "tpl_memmap.h"
   57         /*
   58          * idle_task is the task descriptor of the kernel task
   59          * used when no other task is ready. The OS starts
   60          * by setting this task as the running task (ie the
   61          * init code currently being run.
   62          * It then calls tpl_schedule to start the
   63          * multitasking and falls back in an infinite loop.
   64          */
   65         
   66         /**
   67          * @internal
   68          *
   69          * static part of the idle task descriptor
   70          *
   71          * @see #idle_task
   72          */
   73         _STATIC_ VAR(tpl_exec_static, OS_VAR) idle_task_static = {
   74             /* context              */  IDLE_CONTEXT,
   75             /* no stack             */  IDLE_STACK,
   76             /* no entry point       */  NULL,
   77             /* internal resource    */  NULL,
   78             /* id is INVALID_TASK   */  INVALID_TASK,
   79             /* base priority is 0   */  0,
   80             /* max activate count   */  1,
   81             /* type is BASIC        */  TASK_BASIC,
   82         #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                  /* no timing protection
                     for the idle task :D */  NULL
              #endif
   86         };
   87         
   88         /**
   89          * @internal
   90          *
   91          * idle task descriptor
   92          */
   93         _STATIC_ VAR(tpl_task, OS_VAR) idle_task = {
   94             /*  Common members  */
   95             {
   96             /* static descriptor    */  &idle_task_static,
   97             /* resources            */  NULL,
   98             /* activation count     */  0,
   99             /* priority             */  0,
  100             /* state                */  RUNNING
  101         #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                  /* monitor_start_date   */  ,0,
                  /* time_left            */  0
              #endif
  105             },
  106             /* task members */
  107             /* event set            */  0,
  108             /* event wait           */  0
  109         };
  110         
  111         /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
  112             that has the same beginning fields as the struct it is casted to
  113             This allow object oriented design and polymorphism.
  114         */
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 3   

  115         
  116         /**
  117          * @internal
  118          *
  119          * tpl_running_obj is the currently running task in the application.
  120          *
  121          * At system startup it is set to the idle task
  122          */
  123         P2VAR(tpl_exec_common, OS_APPL_DATA, OS_VAR) tpl_running_obj =
  124             (P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC))&idle_task;
  125         
  126         /**
  127          * @internal
  128          *
  129          * tpl_ready_list is a table that is automatically generated by goil from
  130          * the application description. Indexes of this table are the priority levels
  131          * Each of its elements is a pointer to the fifo used to store task/isr2
  132          * activation instances and the size of this fifo.
  133          */
  134         extern VAR(tpl_priority_level, OS_VAR) tpl_ready_list[];
  135         
  136         /**
  137          * @internal
  138          *
  139          * tpl_fifo_rw is a table that is automatically generated by goil from
  140          * the application description. Indexes of this table are the priority levels
  141          * each of its elements are a read and write index in the fifo.
  142          */
  143         extern VAR(tpl_fifo_state, OS_VAR) tpl_fifo_rw[];
  144         
  145         #define OS_STOP_SEC_VAR_UNSPECIFIED
  146         #include "tpl_memmap.h"
  147         
  148         
  149         #define OS_START_SEC_VAR_8BITS
  150         #include "tpl_memmap.h"
  151         
  152         /**
  153          * @internal
  154          *
  155          * tpl_h_prio is the index of the highest priority non empty fifo
  156          * in the ready list. It is used to speed up scheduling
  157          */
  158         VAR(s8, OS_VAR) tpl_h_prio = -1;
  159         
  160         /*
  161          * tpl_last_result store the last error
  162          * encountered by Trampoline.
  163          * It is used has a return value
  164          * for some OS services and for the
  165          * ErrorHook routine
  166          */
  167         /* tpl_status tpl_last_result = E_OK; */
  168         
  169         VAR(u8, OS_VAR) tpl_os_state = OS_INIT; /* see doc in header file declaration */
  170         
  171         VAR(tpl_resource_id, OS_VAR) RES_SCHEDULER = RESOURCE_COUNT;
  172         /* see doc in header declaration */
  173         
  174         #define OS_STOP_SEC_VAR_8BITS
  175         #include "tpl_memmap.h"
  176         
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 4   

  177         
  178         #define OS_START_SEC_VAR_UNSPECIFIED
  179         #include "tpl_memmap.h"
  180         /**
  181          * The scheduler resource descriptor
  182          *
  183          * @see #RES_SCHEDULER
  184          */
  185         VAR(tpl_resource, OS_VAR) res_sched = {
  186             RES_SCHEDULER_PRIORITY, /**< the ceiling priority is defined as the
  187                                          maximum priority of the tasks of the
  188                                          application                                */
  189             0,                      /*   owner_prev_priority                        */
  190             NULL,                   /*   owner                                      */
  191             NULL                    /*   next_res                                   */
  192         };
  193         
  194         /**
  195          * INTERNAL_RES_SCHEDULER is an internal resource with the higher task priority
  196          * in the application. A task is non preemptable when INTERNAL_RES_SCHEDULER
  197          * is set as internal resource.
  198          */
  199         VAR(tpl_internal_resource, OS_VAR) INTERNAL_RES_SCHEDULER = {
  200             RES_SCHEDULER_PRIORITY, /**< the ceiling priority is defined as the
  201                                          maximum priority of the tasks of the
  202                                          application                                */
  203             0,
  204             NULL
  205         };
  206         
  207         #define OS_STOP_SEC_VAR_UNSPECIFIED
  208         #include "tpl_memmap.h"
  209         
  210         
  211         #define OS_START_SEC_CODE
  212         #include "tpl_memmap.h"
  213         
  214         #ifdef WITH_DOW
              /*
               */
              FUNC(void, OS_CODE) printrl(
                  P2VAR(char, OS_APPL_DATA, AUTOMATIC) msg)
              {
                  int i,j;
                  tpl_exec_common **level;
                  int size;
              
                  printf("%s - Highest: %d\n",msg,tpl_h_prio);
                  for (i = 0; i < PRIO_LEVEL_COUNT; i++)
                  {
                      printf("P%2d: ",i);
                      level = tpl_ready_list[i].fifo;
                      size = tpl_fifo_rw[i].size;
                      for (j = 0; j < tpl_fifo_rw[i].size; j++)
                      {
                          int idx = tpl_fifo_rw[i].read + j;
                          if (idx >= tpl_ready_list[i].size)
                          {
                              idx -= tpl_ready_list[i].size;
                          }
                          printf(" %d",level[idx]->static_desc->id);
                      }
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 5   

                      printf("\n");
                  }
              }
              #endif
  243         
  244         /**
  245          * @internal
  246          *
  247          * tpl_get_exec_object extracts the highest priority ready executable
  248          * object from the executable objects list and returns it.
  249          * tpl_get_exec_object returns NULL if no ready executable object
  250          * is available
  251          *
  252          * @return highest priority executable object descriptor
  253          */
  254         _STATIC_ /*@null@*/
  255         FUNC(P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC), OS_CODE)
  256         tpl_get_exec_object(void)
  257         {
  258  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) elected = NULL ;
  259  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) *highest;
  260  1          VAR(u8, AUTOMATIC)  read_idx;
  261  1      
  262  1          DOW_ASSERT((tpl_h_prio >= 0) && (tpl_h_prio < PRIO_LEVEL_COUNT))
  263  1          DOW_ASSERT(tpl_fifo_rw[tpl_h_prio].size > 0)
  264  1      
  265  1          DOW_DO(printrl("tpl_get_exec_object - avant");)
  266  1      
  267  1          /*  Get the highest priority non empty fifo                         */
  268  1          highest = tpl_ready_list[tpl_h_prio].fifo;
  269  1      
  270  1          /*  Get the read index                                              */
  271  1          read_idx = tpl_fifo_rw[tpl_h_prio].read;
  272  1      
  273  1          /*  The fifo is not empty, get the descriptor                       */
  274  1          elected = highest[read_idx];
  275  1      
  276  1          /*  Adjust the read index and the size                              */
  277  1          read_idx++;
  278  1          if (read_idx >= tpl_ready_list[tpl_h_prio].size)
  279  1          {
  280  2              read_idx = 0;
  281  2          }
  282  1          tpl_fifo_rw[tpl_h_prio].read = read_idx;
  283  1          tpl_fifo_rw[tpl_h_prio].size--;
  284  1      
  285  1          /*  Adjust the highest priority non empty fifo index                */
  286  1          while ((tpl_h_prio >= 0) && (tpl_fifo_rw[tpl_h_prio].size == 0))
  287  1          {
  288  2              tpl_h_prio--;
  289  2          }
  290  1      
  291  1          DOW_DO(printrl("tpl_get_exec_object - apres");)
  292  1      
  293  1          return elected;
  294  1      }
  295         
  296         /**
  297          * @internal
  298          *
  299          * tpl_put_preempted_exec_object put a preempted executable object
  300          * in the ready executable object list
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 6   

  301          *
  302          * @param exec_obj address of the executable object descriptor
  303          */
  304         FUNC(void, OS_CODE)
  305         tpl_put_preempted_exec_object(
  306             P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) exec_obj)
  307         {
  308  1          /*  Get the current priority of the executable object                   */
  309  1          VAR(tpl_priority, AUTOMATIC)                    prio;
  310  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) *fifo;
  311  1          VAR(u8, AUTOMATIC)                              write_idx;
  312  1      
  313  1          DOW_DO(printrl("tpl_put_prempted_exec_object - avant");)
  314  1      
  315  1          /*  the priority used as level in the ready list
  316  1              for a preempted object is the current priority                  */
  317  1          prio = exec_obj->priority;
  318  1      
  319  1          DOW_ASSERT((prio >= 0) && (prio < PRIO_LEVEL_COUNT))
  320  1          DOW_ASSERT(tpl_fifo_rw[prio].size < tpl_ready_list[prio].size)
  321  1      
  322  1          /*  a preempted executable object is put at the head of the fifo    */
  323  1          write_idx = tpl_fifo_rw[prio].read - 1 ;
  324  1      
  325  1          /*  since write_idx is unsigned, an overflow could occur            */
  326  1          if (write_idx >= tpl_ready_list[prio].size) {
  327  2              write_idx = tpl_ready_list[prio].size - 1;
  328  2          }
  329  1          tpl_fifo_rw[prio].read = write_idx;
  330  1      
  331  1          /*  Get the corresponding fifo                                          */
  332  1          fifo = tpl_ready_list[prio].fifo;
  333  1      
  334  1          /*  put the executable object in it */
  335  1          fifo[write_idx] = exec_obj ;
  336  1      
  337  1          /* adjust the size                                                      */
  338  1          tpl_fifo_rw[prio].size++;
  339  1      
  340  1          /* adjust the highest priority non empty fifo                           */
  341  1          if (prio > tpl_h_prio) {
  342  2              tpl_h_prio = prio;
  343  2          }
  344  1      
  345  1          DOW_DO(printrl("tpl_put_preempted_exec_object - apres");)
  346  1      }
  347         
  348         /**
  349          * @internal
  350          *
  351          * tpl_put_new_exec_object put a newly activated executable object
  352          * in the ready executable object list
  353          *
  354          * @param exec_obj address of the executable object descriptor
  355          */
  356         FUNC(void, OS_CODE) tpl_put_new_exec_object(
  357             P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) exec_obj)
  358         {
  359  1          /*  Get the current priority of the executable object                   */
  360  1          VAR(tpl_priority, AUTOMATIC)    prio;
  361  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) *fifo;
  362  1          VAR(u8, AUTOMATIC)              write_idx;
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 7   

  363  1      
  364  1          DOW_DO(printrl("tpl_put_new_exec_object - avant");)
  365  1      
  366  1          /*  the priority used as level in the ready list
  367  1              for a newly activated object is the base priority               */
  368  1          prio = exec_obj->static_desc->base_priority ;
  369  1      
  370  1          DOW_ASSERT((prio >= 0) && (prio < PRIO_LEVEL_COUNT))
  371  1          DOW_ASSERT(tpl_fifo_rw[prio].size < tpl_ready_list[prio].size)
  372  1      
  373  1          /*  a newly activated executable object
  374  1              is put at the end of the fifo                                   */
  375  1          write_idx = tpl_fifo_rw[prio].read + tpl_fifo_rw[prio].size;
  376  1      
  377  1          /*  adjust the write index                                          */
  378  1          if (write_idx >= tpl_ready_list[prio].size) {
  379  2               write_idx -= tpl_ready_list[prio].size;
  380  2          }
  381  1      
  382  1          /*  Get the corresponding fifo                                          */
  383  1          fifo = tpl_ready_list[prio].fifo;
  384  1      
  385  1          /*  put the executable object in it */
  386  1          fifo[write_idx] = exec_obj ;
  387  1      
  388  1          /* adjust the size                                                      */
  389  1          tpl_fifo_rw[prio].size++;
  390  1      
  391  1          /* adjust the highest priority non empty fifo                           */
  392  1          if (prio > tpl_h_prio) {
  393  2              tpl_h_prio = prio;
  394  2          }
  395  1      
  396  1          DOW_DO(printrl("tpl_put_new_exec_object - apres");)
  397  1      }
  398         
  399         /**
  400          * @internal
  401          *
  402          * Get an internal resource
  403          *
  404          * @param task task from which internal resource is got
  405          */
  406         FUNC(void, OS_CODE) tpl_get_internal_resource(
  407             P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) a_task)
  408         {
  409  1          P2VAR(tpl_internal_resource, OS_APPL_DATA, AUTOMATIC) rez =
  410  1              a_task->static_desc->internal_resource;
  411  1      
  412  1          if ((rez != NULL) && (rez->taken == FALSE))
  413  1          {
  414  2              rez->taken = TRUE;
  415  2              rez->owner_prev_priority = a_task->priority;
  416  2              a_task->priority = rez->ceiling_priority;
  417  2          }
  418  1      }
  419         
  420         /**
  421          * @internal
  422          *
  423          * Release an internal resource
  424          *
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 8   

  425          * @param task task from which internal resource is released
  426          */
  427         FUNC(void, OS_CODE) tpl_release_internal_resource(
  428             P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) a_task)
  429         {
  430  1          P2VAR(tpl_internal_resource, OS_APPL_DATA, AUTOMATIC) rez =
  431  1              a_task->static_desc->internal_resource;
  432  1      
  433  1          if ((rez != NULL) && (rez->taken == TRUE))
  434  1          {
  435  2              rez->taken = FALSE;
  436  2              a_task->priority = rez->owner_prev_priority;
  437  2          }
  438  1      }
  439         
  440         /**
  441          * @internal
  442          *
  443          * Does the scheduling
  444          *
  445          * This function is called by the OSEK/VDX Schedule service
  446          * and by various function when a rescheduling is needed
  447          *
  448          * @param from can be one of #FROM_TASK_LEVEL or #FROM_IT_LEVEL
  449          */
  450         FUNC(void, OS_CODE) tpl_schedule(CONST(u8, AUTOMATIC) from)
  451         {
  452  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) old_running_obj;
  453  1      
  454  1          /*  the tpl_running_obj is never NULL and may be in 3 states
  455  1              - RUNNING:      if the running object is in the RUNNING state and
  456  1                              loses the CPU because a higher priority task is in
  457  1                              the ready list, its context must be saved.
  458  1              - WAITING:      if the running object is in the WAITING state, its
  459  1                              context must be saved and it loses the CPU.
  460  1              - RESURRECT:    if the running object is in the RESURRECT state,
  461  1                              its context is not saved, it is put as
  462  1                              READY_AND_NEW in the ready list.
  463  1              - DYING:        if the running object is in the DYING state, its
  464  1                              context is not saved and it loses the CPU.          */
  465  1          tpl_exec_state state = tpl_running_obj->state;
  466  1      
  467  1          tpl_bool schedule =
  468  1              (tpl_h_prio != -1) &&
  469  1              (((state & 0x3) == 0x3) ||    /*  DYING, WAITING or RESURRECT */
  470  1               (state == (tpl_exec_state)RUNNING &&
  471  1                tpl_h_prio > tpl_running_obj->priority));
  472  1      
  473  1      #ifdef WITH_AUTOSAR_STACK_MONITORING
                 tpl_check_stack (tpl_running_obj);
              #endif /* WITH_AUTOSAR_STACK_MONITORING */
  476  1      
  477  1          if (schedule == TRUE)
  478  1          {
  479  2              /*  save the old running task for context switching */
  480  2              old_running_obj = tpl_running_obj;
  481  2      
  482  2              /*  a task switch will occur. It is time to call the
  483  2                  PostTaskHook while the soon descheduled task is running     */
  484  2              CALL_POST_TASK_HOOK()
  485  2      
  486  2              if (state == RUNNING)
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 9   

  487  2              {
  488  3                  /*  the current running task become READY                   */
  489  3                  tpl_running_obj->state = (tpl_exec_state)READY;
  490  3                  /*  put the running task in the ready task list             */
  491  3                  /*  Bug fix. preempted objects are put at the head
  492  3                      of the set while newly activated objects are
  493  3                      put at the end of the set. So we have to
  494  3                      distinguish them                                        */
  495  3                  tpl_put_preempted_exec_object(tpl_running_obj);
  496  3                  #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                          /*
                           * pause the budget monitor for a task
                           */
                          if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                            tpl_pause_budget_monitor (tpl_running_obj);
                          #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  503  3              }
  504  2              else
  505  2              {
  506  3                  #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                          if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                          {
                            /* pause the budget monitoring when a task has ended
                             * FIXME : should we pause or finish the budget
                             * monitor in the case a task terminates before
                             * the end of the timeframe ?
                             */
                            tpl_pause_budget_monitor (tpl_running_obj);
                          }
                          else
                          {
                            /* when an ISR2 ends, check for execution time */
                            tpl_finish_exectime_monitor (tpl_running_obj);
                          }
                          #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  522  3      
  523  3                  /*  the task loses the CPU because it has been put in the
  524  3                      WAITING or in the DYING state, its internal resource
  525  3                      is released.                                            */
  526  3                  tpl_release_internal_resource(tpl_running_obj);
  527  3      
  528  3                  if (state == (tpl_exec_state)DYING)
  529  3                  {
  530  4                      /*  if the running object is dying, the activate count
  531  4                          is decreased                                        */
  532  4                      tpl_running_obj->activate_count--;
  533  4      
  534  4                      /*  and checked to compute its state.                   */
  535  4                      if (tpl_running_obj->activate_count > 0)
  536  4                      {
  537  5                          /*  there is at least one instance of the dying
  538  5                              running object in the ready list. So it is put
  539  5                              in the READY_AND_NEW state. This way when the
  540  5                              next instance will be prepared to run it will
  541  5                              be initialized.                                 */
  542  5                          tpl_running_obj->state = READY_AND_NEW;
  543  5                      }
  544  4                      else
  545  4                      {
  546  5                          /*  there is no instance of the dying running
  547  5                              object in the ready list. So it is put in the
  548  5                              SUSPENDED state.                                */
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 10  

  549  5                          tpl_running_obj->state = SUSPENDED;
  550  5                      }
  551  4                  }
  552  3      
  553  3                  if (state == (tpl_exec_state)RESURRECT)
  554  3                  {
  555  4                      /*  This case happens when a task chains to itself
  556  4                          by calling ChainTask                                */
  557  4                      tpl_running_obj->state = READY_AND_NEW;
  558  4                      tpl_put_new_exec_object(tpl_running_obj);
  559  4                  }
  560  3      
  561  3              }
  562  2      
  563  2              /*  get the ready task from the ready task list                 */
  564  2              tpl_running_obj = tpl_get_exec_object();
  565  2      
  566  2              if (tpl_running_obj->state == READY_AND_NEW)
  567  2              {
  568  3                  /*  the object has not be preempted. So its
  569  3                      descriptor must be initialized              */
  570  3                  tpl_init_exec_object(tpl_running_obj);
  571  3                  #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                          if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                          {
                            /* start the budget monitor for the activated task */
                            tpl_start_budget_monitor (tpl_running_obj);
                          }
                          else
                          {
                            /* add an activation count for the ISR2 and starts the
                             * execution time monitor */
                            tpl_add_activation_count (tpl_running_obj);
                            tpl_start_exectime_monitor (tpl_running_obj);
                          }
                          #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  585  3              }
  586  2              else
  587  2              {
  588  3                #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                        if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                          tpl_continue_budget_monitor (tpl_running_obj);
                        #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  592  3              }
  593  2              /*  the inserted task become RUNNING                */
  594  2              tpl_running_obj->state = RUNNING;
  595  2              /*  If an internal resource is assigned to the task
  596  2                  and it is not already taken by it, take it      */
  597  2              tpl_get_internal_resource(tpl_running_obj);
  598  2      
  599  2              /*  A new task has been elected
  600  2                  It is time to call PreTaskHook while the
  601  2                  rescheduled task is running                     */
  602  2              CALL_PRE_TASK_HOOK()
  603  2      
  604  2              if (tpl_running_obj ==
  605  2                  (P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC))&idle_task)
  606  2              {
  607  3                  tpl_os_state = OS_IDLE;
  608  3              }
  609  2              else if (tpl_running_obj->static_desc->type == IS_ROUTINE)
  610  2              {
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 11  

  611  3                  tpl_os_state = OS_ISR2;
  612  3              }
  613  2              else
  614  2              {
  615  3                  tpl_os_state = OS_TASK;
  616  3              }
  617  2              /*  Switch the context  */
  618  2              if (from == (u8)FROM_TASK_LEVEL)
  619  2              {
  620  3                  if (state < 0x4)
  621  3                  {
  622  4                      DOW_ASSERT(tpl_running_obj != old_running_obj)
  623  4                      /*  The old running object is not in a DYING or
  624  4                          RESSURECT state */
  625  4                      tpl_switch_context(
  626  4                          &(old_running_obj->static_desc->context),
  627  4                          &(tpl_running_obj->static_desc->context));
  628  4                  }
  629  3                  else
  630  3                  {
  631  4                      tpl_switch_context(
  632  4                          NULL,
  633  4                          &(tpl_running_obj->static_desc->context));
  634  4                  }
  635  3              }
  636  2              else
  637  2              { /* FROM_IT_LEVEL */
  638  3                  if (state < 0x4)
  639  3                  {
  640  4                      /*  The old running object is not in a DYING or
  641  4                          RESSURECT state */
  642  4                      tpl_switch_context_from_it(
  643  4                          &(old_running_obj->static_desc->context),
  644  4                          &(tpl_running_obj->static_desc->context));
  645  4                  }
  646  3                  else
  647  3                  {
  648  4                      tpl_switch_context_from_it(
  649  4                          NULL,
  650  4                          &(tpl_running_obj->static_desc->context));
  651  4                  }
  652  3              }
  653  2          }
  654  1      }
  655         
  656         /**
  657          * @internal
  658          *
  659          * Does the scheduling when called from a running object.
  660          *
  661          * This function is called by the OSEK/VDX Schedule
  662          * and ActivateTask services 
  663          * 
  664          */
  665         FUNC(void, OS_CODE) tpl_schedule_from_running(void)
  666         {
  667  1          P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC) old_running_obj = NULL;
  668  1          
  669  1          /*  the tpl_running_obj is never NULL and is in the state RUNNING  */
  670  1          DOW_ASSERT(tpl_running_obj != NULL);
  671  1          DOW_ASSERT(tpl_running_obj->state == RUNNING);
  672  1          DOW_ASSERT(tpl_h_prio != -1);
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 12  

  673  1      
  674  1      #ifdef WITH_AUTOSAR_STACK_MONITORING
                  tpl_check_stack (tpl_running_obj);
              #endif /* WITH_AUTOSAR_STACK_MONITORING */
  677  1          
  678  1          if (tpl_h_prio > tpl_running_obj->priority)
  679  1          {
  680  2              /*  save the old running task for context switching */
  681  2              old_running_obj = tpl_running_obj;
  682  2      
  683  2              /*  a task switch will occur. It is time to call the
  684  2                  PostTaskHook while the soon descheduled task is running     */
  685  2              CALL_POST_TASK_HOOK()
  686  2                  
  687  2                  /*  the current running task become READY                   */
  688  2              tpl_running_obj->state = (tpl_exec_state)READY;
  689  2              /*  put the running task in the ready task list             */
  690  2              /*  Bug fix. preempted objects are put at the head
  691  2                  of the set while newly activated objects are
  692  2                  put at the end of the set. So we have to
  693  2                  distinguish them                                        */
  694  2              tpl_put_preempted_exec_object(tpl_running_obj);
  695  2      
  696  2              #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                      /*
                       * pause the budget monitor for a task
                       */
                      if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                        tpl_pause_budget_monitor (tpl_running_obj);
                      #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  703  2              
  704  2      
  705  2              /*  get the ready task from the ready task list                 */
  706  2              tpl_running_obj = tpl_get_exec_object();
  707  2      
  708  2              if (tpl_running_obj->state == READY_AND_NEW)
  709  2              {
  710  3                  /*  the object has not be preempted. So its
  711  3                      descriptor must be initialized              */
  712  3                  tpl_init_exec_object(tpl_running_obj);
  713  3                  #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                          if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                          {
                            /* start the budget monitor for the activated task */
                            tpl_start_budget_monitor (tpl_running_obj);
                          }
                          else
                          {
                            /* add an activation count for the ISR2 and starts the
                             * execution time monitor */
                            tpl_add_activation_count (tpl_running_obj);
                            tpl_start_exectime_monitor (tpl_running_obj);
                          }
                          #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  727  3              }
  728  2      #ifdef WITH_AUTOSAR_TIMING_PROTECTION
                      else
                      {
                          if (tpl_running_obj->static_desc->type != IS_ROUTINE)
                          {
                              tpl_continue_budget_monitor (tpl_running_obj);
                          }
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 13  

                      }
              #endif /* WITH_AUTOSAR_TIMING_PROTECTION */
  737  2      
  738  2              /*  the inserted task become RUNNING                */
  739  2              tpl_running_obj->state = RUNNING;
  740  2              /*  If an internal resource is assigned to the task
  741  2                  and it is not already taken by it, take it      */
  742  2              tpl_get_internal_resource(tpl_running_obj); 
  743  2              
  744  2              /*  A new task has been elected
  745  2                  It is time to call PreTaskHook while the
  746  2                  rescheduled task is running                     */
  747  2              CALL_PRE_TASK_HOOK()
  748  2          
  749  2              if (tpl_running_obj == (tpl_exec_common *)&idle_task)
  750  2              {
  751  3                  tpl_os_state = OS_IDLE;
  752  3              }
  753  2              else if (tpl_running_obj->static_desc->type == IS_ROUTINE)
  754  2              {
  755  3                  tpl_os_state = OS_ISR2;
  756  3              }
  757  2              else
  758  2              {
  759  3                  tpl_os_state = OS_TASK;
  760  3              }
  761  2              DOW_ASSERT(tpl_running_obj != old_running_obj)
  762  2              /*  The old running object is not in a DYING or
  763  2                  RESSURECT state */
  764  2              tpl_switch_context(
  765  2                  &(old_running_obj->static_desc->context),
  766  2                  &(tpl_running_obj->static_desc->context));
  767  2          }
  768  1      }
  769         
  770         /**
  771          * @internal
  772          *
  773          * This function is called by OSEK/VDX ActivateTask and by
  774          * the raise of an alarm.
  775          *
  776          * the activation count is incremented
  777          * if the task is in the SUSPENDED state, it is moved
  778          * to the task list
  779          *
  780          * @param task reference of the task's identifier
  781          */
  782         FUNC(tpl_status, OS_CODE) tpl_activate_task(
  783             P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC) a_task)
  784         {
  785  1          VAR(tpl_status, AUTOMATIC)              result = E_OS_LIMIT;
  786  1          VAR(tpl_activate_counter, AUTOMATIC)    count = a_task->exec_desc.activate_count;
  787  1      
  788  1          if (count < a_task->exec_desc.static_desc->max_activate_count)
  789  1          {
  790  2              if (count == 0)
  791  2              {
  792  3                  if (a_task->exec_desc.static_desc->type == TASK_EXTENDED)
  793  3                  {
  794  4                      /*  if the task is an extended one, it is inited now        */
  795  4                      a_task->exec_desc.state = (tpl_exec_state)READY;
  796  4                      tpl_init_exec_object(&a_task->exec_desc);
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 14  

  797  4                  }
  798  3                  else
  799  3                  {
  800  4                      /*  if it is a basic task, its initialization
  801  4                          is postponed to the time it will get the CPU            */
  802  4                      a_task->exec_desc.state = (tpl_exec_state)READY_AND_NEW;
  803  4                  }
  804  3              }
  805  2              /*  put it in the list  */
  806  2              tpl_put_new_exec_object(&(a_task->exec_desc));
  807  2              /*  inc the task activation count. When the task will terminate
  808  2                  it will dec this count and if not zero it will be reactivated   */
  809  2              a_task->exec_desc.activate_count++;
  810  2      
  811  2              result = (tpl_status)E_OK_AND_SCHEDULE;
  812  2          }
  813  1      
  814  1          return result;
  815  1      }
  816         
  817         /**
  818          * @internal
  819          *
  820          * This function is used by SetEvent and by tpl_raise_alarm
  821          *
  822          * @param task              Pointer to the task descriptor
  823          * @param incoming_event    Event mask
  824          */
  825         FUNC(tpl_status, OS_CODE) tpl_set_event(
  826             P2VAR(tpl_task, OS_APPL_CODE, AUTOMATIC)  a_task,
  827             CONST(tpl_event_mask, AUTOMATIC)          incoming_event)
  828         {
  829  1          VAR(tpl_status, AUTOMATIC) result = E_OK;
  830  1      
  831  1          if (a_task->exec_desc.state != (tpl_exec_state)SUSPENDED)
  832  1          {
  833  2              /*  merge the incoming event mask with the old one  */
  834  2              a_task->evt_set = (tpl_event_mask)(a_task->evt_set | incoming_event);
  835  2              /*  cross check the event the task is
  836  2                  waiting for and the incoming event              */
  837  2              if ((a_task->evt_wait & incoming_event) != 0)
  838  2              {
  839  3                  /*  the task was waiting for at least one of the event set
  840  3                      the wait mask is reset to 0                 */
  841  3                  a_task->evt_wait = (tpl_event_mask)0;
  842  3                  /*  anyway check it is in the WAITING state     */
  843  3                  if (a_task->exec_desc.state == (tpl_exec_state)WAITING)
  844  3                  {
  845  4                      /*  set the state to READY  */
  846  4                      a_task->exec_desc.state = (tpl_exec_state)READY;
  847  4                      /*  put the task in the READY list          */
  848  4      
  849  4                      /*  MISRA RULE 45 VIOLATION: the original pointer points to
  850  4                          a struct that has the same beginning fields as the struct
  851  4                          it is casted to. This allow object oriented design and
  852  4                          polymorphism.
  853  4                      */
  854  4                      tpl_put_new_exec_object(
  855  4                          (P2VAR(tpl_exec_common, OS_APPL_DATA, AUTOMATIC))a_task);
  856  4                      /*  notify a scheduling needs to be done    */
  857  4                      result = (tpl_status)E_OK_AND_SCHEDULE;
  858  4                  }
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 15  

  859  3              }
  860  2          }
  861  1          else
  862  1          {
  863  2              result = E_OS_STATE;
  864  2          }
  865  1      
  866  1          return result;
  867  1      }
  868         
  869         /**
  870          * @internal
  871          *
  872          * Executable object initialization.
  873          *
  874          * This function initialize the common part of task
  875          * or category 2 interrupt service routine to make them ready
  876          * for execution. If the object is an task it initializes
  877          * the event masks too (this has no effect on basic tasks).
  878          *
  879          * @param exec_obj address of the executable object descriptor
  880          */
  881         FUNC(void, OS_CODE) tpl_init_exec_object(
  882             P2VAR(tpl_exec_common, OS_APPL_CODE, AUTOMATIC) exec_obj)
  883         {
  884  1          /*  The priority is set to the base priority of the executable object    */
  885  1          exec_obj->priority = exec_obj->static_desc->base_priority;
  886  1          /*  set the resources list to NULL   */
  887  1          exec_obj->resources = NULL;
  888  1          /*  context init is machine dependant
  889  1              tpl_init_context is defined in tpl_machine.c    */
  890  1          tpl_init_context(exec_obj);
  891  1          /*  if the object is a task, init the events    */
  892  1          if ((exec_obj->static_desc->type & IS_ROUTINE) == 0)
  893  1          {
  894  2              /*  MISRA RULE 45 VIOLATION: the original pointer points to a struct
  895  2                  that has the same beginning fields as the struct it is casted to
  896  2                  This allow object oriented design and polymorphism.
  897  2              */
  898  2              ((P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC))exec_obj)->evt_set =
  899  2                  ((P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC))exec_obj)->evt_wait = 0;
  900  2          }
  901  1      }
  902         
  903         /**
  904          * @internal
  905          *
  906          * Initialization of Trampoline
  907          */
  908         FUNC(void, OS_CODE) tpl_init_os(CONST(tpl_application_mode, AUTOMATIC) app_mode)
  909         {
  910  1          VAR(u16, AUTOMATIC) i;
  911  1      #ifndef NO_ALARM
  912  1          P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC) auto_time_obj;
  913  1      #endif
  914  1      
  915  1      #ifdef WITH_AUTOSAR
                  #ifdef NO_ALARM
                      #ifndef NO_SCHEDTABLE
                  P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC) auto_time_obj;
                      #endif
                  #endif
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 16  

              #endif
  922  1      
  923  1      #ifndef NO_TASK
  924  1          P2VAR(tpl_task, OS_APPL_DATA, AUTOMATIC) auto_task;
  925  1      
  926  1          /*  Look for autostart tasks    */
  927  1      
  928  1          for (i = 0; i < TASK_COUNT; i++)
  929  1          {
  930  2              auto_task = tpl_task_table[i];
  931  2              if (auto_task->exec_desc.state == (tpl_exec_state)AUTOSTART)
  932  2              {
  933  3                  /*  each AUTOSTART task is activated   */
  934  3                  tpl_activate_task(auto_task);
  935  3              }
  936  2          }
  937  1      #endif
  938  1      #ifndef NO_ALARM
  939  1      
  940  1          /*  Look for autostart alarms    */
  941  1      
  942  1          for (i = 0; i < ALARM_COUNT; i++)
  943  1          {
  944  2              auto_time_obj = (P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC))tpl_alarm_table[i];
  945  2              if (auto_time_obj->state == (tpl_time_obj_state)ALARM_AUTOSTART)
  946  2              {
  947  3                  auto_time_obj->state = ALARM_ACTIVE;
  948  3                  tpl_insert_time_obj(auto_time_obj);
  949  3              }
  950  2          }
  951  1      
  952  1      #endif
  953  1      #if defined WITH_AUTOSAR && !defined NO_SCHEDTABLE
                  /*  Look for autostart schedule tables  */
              
                  for (i = 0; i < SCHEDTABLE_COUNT; i++)
                  {
                      auto_time_obj = (P2VAR(tpl_time_obj, OS_APPL_DATA, AUTOMATIC))tpl_schedtable_table[i];
                      if (auto_time_obj->state == (tpl_time_obj_state)SCHEDULETABLE_AUTOSTART)
                      {
                          auto_time_obj->state = SCHEDULETABLE_RUNNING;
                          tpl_insert_time_obj(auto_time_obj);
                      }
                  }
              #endif
  966  1      }
*** WARNING C47 IN LINE 908 OF ..\..\..\TRAMPOLINE-1.1\OS\TPL_OS_KERNEL.C: 'app_mode': unreferenced parameter
  967         
  968         #define OS_STOP_SEC_CODE
  969         #include "tpl_memmap.h"
  970         
  971         /* End of file tpl_os_kernel.c */


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        1034     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          45     --------
  FAR-DATA SIZE    =    --------     --------
C166 COMPILER V6.08, TPL_OS_KERNEL                                                         06/28/2009 16:38:40 PAGE 17  

  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          80     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
